<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Math Royale</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      background: #f9f9f9;
      color: #333;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      position: relative;
      touch-action: manipulation;
    }

    /* ===== é ‚éƒ¨æ“ä½œæ¬„ï¼ˆå›ºå®šï¼‰===== */
    .top-bar {
      width: 100%;
      max-width: 600px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 12px 0;
      position: sticky;
      top: 0;
      background: white;
      z-index: 100;
    }
    .top-btn {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background: #6c5ce7;
      color: white;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .top-btn.muted { background: #95a5a6; }

    /* ===== ä¸»éŠæˆ²å®¹å™¨ ===== */
    .game-container {
      width: 100%;
      max-width: 600px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
      padding: 20px;
      margin: 16px 0;
    }

    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 16px;
      font-size: 24px;
      font-weight: bold;
    }

    .score-time {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
      font-weight: bold;
      font-size: 16px;
    }

    .timer-bar {
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
    }
    .timer-fill {
      height: 100%;
      background: #0984e3;
      width: 100%;
      transition: width 0.1s linear;
    }

    .target-row {
      display: flex;
      justify-content: center;
      margin: 16px 0;
    }
    .target-card {
      width: 60px;
      height: 76px;
      border: 2px solid #d63031;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      background: #ffeaa7;
    }

    .hand-area {
      min-height: 100px;
      height: 100px;
      margin: 16px 0;
      padding: 0 8px;
      background: #fafafa;
      border-radius: 12px;
      display: flex;
      flex-wrap: nowrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .card {
      width: calc(16vw - 12px);
      min-width: 50px;
      max-width: 60px;
      flex-shrink: 0;
      height: 76px;
      border: 2px solid #333;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      background: white;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.2s;
    }
    .card.selected-first {
      border-color: #0984e3;
      transform: scale(1.08);
      box-shadow: 0 0 12px rgba(9, 132, 227, 0.5);
    }

    .operator-menu {
      display: none;
      justify-content: center;
      gap: 12px;
      margin: 16px 0;
      height: 56px;
    }
    .op-btn {
      width: 48px;
      height: 48px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 50%;
      background: #0984e3;
      color: white;
      cursor: pointer;
    }
    .cancel-btn {
      padding: 6px 14px;
      background: #ff7675;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    }

    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 16px 0;
    }
    .btn {
      padding: 8px 14px;
      font-size: 15px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: #0984e3;
      color: white;
      font-weight: bold;
      flex: 1;
      min-width: 80px;
    }
    #hintBtn { background: #00b894; }
    #nextBtn { background: #fdcb6e; color: #2d3436; }
    #resetBtn { background: #a29bfe; }

    .message {
      margin-top: 16px;
      padding: 10px;
      border-radius: 10px;
      font-weight: bold;
      text-align: center;
      font-size: 14px;
    }
    .success { background: #d5f4e6; color: #00a86b; }
    .error { background: #ffdddd; color: #d63031; }
    .info { background: #e3f2fd; color: #0984e3; }

    /* ===== Modal é€šç”¨ ===== */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      max-width: 90vw;
      max-height: 85vh;
      overflow-y: auto;
      position: relative;
    }

    /* ç©æ³•èªªæ˜ï¼šç™½è‰²èƒŒæ™¯ */
    #instructionsModal .modal-content {
      background: white;
      text-align: left;
    }
    #langToggleInModal {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: #6c5ce7;
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #instructionsModal .close {
      float: right;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      color: #aaa;
    }

    /* æˆåŠŸ/å¤±æ•—å½ˆçª—ï¼šç¸®å° */
    #successModal .modal-content,
    #failureModal .modal-content {
      max-width: 320px;
      padding: 18px;
    }

    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 16px;
    }
    .action-btn {
      flex: 1;
      padding: 8px 4px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: bold;
      cursor: pointer;
      min-height: 50px;
    }
    .btn-icon {
      font-size: 18px;
      margin-bottom: 3px;
      display: block;
    }
    .restart-btn { background: #6c5ce7; color: white; }
    .continue-btn { background: #00a86b; color: white; }
    #failureModal .continue-btn { background: #d63031; }

    .share-btn {
      background: #e17055;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 12px;
      width: 100%;
    }
    .share-btn:hover { background: #d63031; }

    @media (max-width: 500px) {
      .game-container { padding: 16px; }
      .card { font-size: 15px; }
      .btn { font-size: 14px; padding: 8px 10px; }
    }
  </style>
</head>
<body>

  <!-- é ‚éƒ¨æ“ä½œæ¬„ -->
  <div class="top-bar">
    <button class="top-btn" id="helpBtn" title="ç©æ³•èªªæ˜">?</button>
    <button class="top-btn" id="volumeBtn" onclick="toggleVolume()" title="é–‹é—œéŸ³æ•ˆ">ğŸ”Š</button>
  </div>

  <!-- éŠæˆ²ä¸»é«” -->
  <div class="game-container">
    <h1 id="gameTitle">Math Royale</h1>

    <div class="score-time">
      <div>ğŸ† <span id="scoreLabel">åˆ†æ•¸</span>: <span id="score">0</span></div>
      <div>â±ï¸ <span id="timeLabel">æ™‚é–“</span>: <span id="timeLeft">60</span>s</div>
    </div>
    <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>

    <div class="target-row">
      <div class="target-card" id="targetCard">?</div>
    </div>
    <div class="hand-area" id="handArea"></div>

    <div class="operator-menu" id="operatorMenu">
      <button class="op-btn" onclick="selectOperator('+')">+</button>
      <button class="op-btn" onclick="selectOperator('âˆ’')">âˆ’</button>
      <button class="op-btn" onclick="selectOperator('Ã—')">Ã—</button>
      <button class="op-btn" onclick="selectOperator('Ã·')">Ã·</button>
      <button class="cancel-btn" onclick="cancelSelection()" id="cancelBtn">å–æ¶ˆ</button>
    </div>

    <div class="buttons">
      <button class="btn" id="hintBtn" onclick="showMessage(showHint(), 'info')">æç¤º</button>
      <button class="btn" id="nextBtn" onclick="newGame()">æ›ä¸€é¡Œ</button>
      <button class="btn" id="resetBtn" onclick="resetHand()">é‡ä¾†</button>
    </div>

    <div id="message" class="message info">ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼</div>
  </div>

  <!-- ç©æ³•èªªæ˜ -->
  <div id="instructionsModal" class="modal">
    <div class="modal-content">
      <button id="langToggleInModal" onclick="toggleLanguageInModal()">ğŸŒ</button>
      <span class="close" onclick="alert(currentLang==='en'?'Please click \"Start Game!\" button to begin.':'è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚')">&times;</span>
      <div class="instructions">
        <h2 id="instructionsTitle">ğŸ® ç©æ³•èªªæ˜</h2>
        <ul id="instructionsList"></ul>
        <p style="text-align:center; margin-top:16px;">
          <button class="btn" onclick="startGameFromInstructions()" id="startGameBtn">é–‹å§‹éŠæˆ²ï¼</button>
        </p>
      </div>
    </div>
  </div>

  <!-- æˆåŠŸå½ˆçª— -->
  <div id="successModal" class="modal">
    <div class="modal-content">
      <h2 id="successTimeMessage">ğŸ‰ ä½ èŠ±äº† X ç§’å®Œæˆï¼</h2>
      <p id="successMessage"></p>
      <button class="share-btn" onclick="shareChallenge()">
        <span>ğŸ“¤</span>
        <span id="shareBtnText">åˆ†äº«æŒ‘æˆ°</span>
      </button>
      <div class="action-buttons">
        <button class="action-btn restart-btn" onclick="restartGame()">
          <span class="btn-icon">ğŸ”„</span>
          <span id="restartBtnText">é‡æ–°é–‹å§‹</span>
        </button>
        <button class="action-btn continue-btn" onclick="continueChallenge()">
          <span class="btn-icon">âš¡</span>
          <span id="continueBtnText">ç¹¼çºŒæŒ‘æˆ°</span>
        </button>
      </div>
    </div>
  </div>

  <!-- å¤±æ•—å½ˆçª— -->
  <div id="failureModal" class="modal">
    <div class="modal-content">
      <h2 id="failureTitle">ğŸ’ª å†è©¦ä¸€æ¬¡ï¼</h2>
      <p id="failureMessage"></p>
      <button class="share-btn" onclick="shareChallenge()">
        <span>ğŸ“¤</span>
        <span id="shareBtnText2">åˆ†äº«æŒ‘æˆ°</span>
      </button>
      <div class="action-buttons">
        <button class="action-btn restart-btn" onclick="restartGame()">
          <span class="btn-icon">ğŸ”„</span>
          <span id="restartBtnText2">é‡æ–°é–‹å§‹</span>
        </button>
        <button class="action-btn continue-btn" onclick="continueChallenge()">
          <span class="btn-icon">âš¡</span>
          <span id="continueBtnText2">ç¹¼çºŒæŒ‘æˆ°</span>
        </button>
      </div>
    </div>
  </div>

  <!-- =============== å®Œæ•´ Math Royale é‚è¼¯ï¼ˆä¾†è‡ªæ‚¨æä¾›çš„æª”æ¡ˆï¼‰=============== -->
  <script>
    // ===== èªè¨€è¨­å®š =====
    const translations = {
      zh: {
        gameTitle: "Math Royale",
        scoreLabel: "åˆ†æ•¸",
        timeLabel: "æ™‚é–“",
        messageStart: "ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼",
        hintBtn: "æç¤º",
        nextBtn: "æ›ä¸€é¡Œ",
        resetBtn: "é‡ä¾†",
        cancelBtn: "å–æ¶ˆ",
        instructionsTitle: "ğŸ® ç©æ³•èªªæ˜",
        instructions: [
          "<strong>ğŸ¯ ç›®æ¨™</strong><br>åœ¨ 60 ç§’å…§ç”¨å…¨éƒ¨ 5 å¼µç‰Œç®—å‡ºç›®æ¨™å€¼",
          "<strong>ğŸ® æ“ä½œæ­¥é©Ÿ</strong><br>1ï¸âƒ£ é»æ“Šç¬¬ä¸€å¼µå¡<br>2ï¸âƒ£ é¸æ“‡é‹ç®—ç¬¦ï¼ˆ+ âˆ’ Ã— Ã·ï¼‰<br>3ï¸âƒ£ é»æ“Šç¬¬äºŒå¼µå¡ â†’ è‡ªå‹•è¨ˆç®—",
          "<strong>âœ… å…è¨± / âŒ ç¦æ­¢</strong><br>âœ… å¯ä»¥ä½¿ç”¨åŠ ã€æ¸›ã€ä¹˜ã€é™¤<br>âœ… å¯ä»¥é‡è¤‡ä½¿ç”¨é‹ç®—ç¬¦<br>âŒ ä¸èƒ½ç”¢ç”Ÿè² æ•¸<br>âŒ é™¤æ³•å¿…é ˆæ•´é™¤ï¼ˆç„¡é¤˜æ•¸ï¼‰<br>âŒ ä¸èƒ½é™¤ä»¥é›¶<br>âŒ ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›",
          "<strong>ğŸ† è¨ˆåˆ†</strong><br>æˆåŠŸè§£é¡Œï¼š+100 åˆ†<br>å‰©é¤˜æ™‚é–“ï¼šæ¯ç§’ +10 åˆ†"
        ],
        startGameBtn: "é–‹å§‹éŠæˆ²ï¼",
        successTimeMessage: (time) => `ğŸ‰ ä½ èŠ±äº† ${time} ç§’å®Œæˆï¼`,
        successMessages: [
          "ä½ çœŸæ˜¯æ•¸å­¸å¤©æ‰ï¼",
          "å¤ªç¥äº†ï¼å®Œå…¨æ­£ç¢ºï¼",
          "å®Œç¾è¨ˆç®—ï¼ç„¡å¯æŒ‘å‰”ï¼",
          "æ•¸å­¸å°é”äººå°±æ˜¯ä½ ï¼",
          "ç²¾æº–ç„¡èª¤ï¼å¤ªå²å®³äº†ï¼",
          "è¨ˆç®—è¶…ç´šæº–ç¢ºï¼",
          "ä½ è®“æ•¸å­¸è®Šå¾—è¶…ç°¡å–®ï¼",
          "å®Œç¾è§£é¡Œï¼çœŸæ£’ï¼"
        ],
        failureTitle: "ğŸ’ª å†è©¦ä¸€æ¬¡ï¼",
        failureMessages: [
          "æ²’é—œä¿‚ï¼Œå†è©¦ä¸€æ¬¡ï¼",
          "å·®ä¸€é»å°±æˆåŠŸäº†ï¼",
          "ç¹¼çºŒåŠ æ²¹ï¼Œä½ å¾ˆæ£’ï¼",
          "ä¸è¦æ”¾æ£„ï¼Œä¸‹æ¬¡ä¸€å®šè¡Œï¼",
          "å­¸ç¿’å°±æ˜¯ä¸æ–·å˜—è©¦ï¼",
          "ä½ å·²ç¶“å¾ˆæ¥è¿‘äº†ï¼",
          "æ¯å€‹éŒ¯èª¤éƒ½æ˜¯é€²æ­¥çš„æ©Ÿæœƒï¼",
          "ç›¸ä¿¡è‡ªå·±ï¼Œä½ å¯ä»¥çš„ï¼"
        ],
        shareBtnText: "åˆ†äº«æŒ‘æˆ°",
        restartBtnText: "é‡æ–°é–‹å§‹",
        continueBtnText: "ç¹¼çºŒæŒ‘æˆ°",
        volumeBtnTitle: "é–‹é—œéŸ³æ•ˆ",
        messages: {
          cannotSelfOperate: "ä¸èƒ½èˆ‡è‡ªå·±é‹ç®—ï¼",
          selectFirstCard: "è«‹å…ˆé¸æ“‡ç¬¬ä¸€å¼µå¡ï¼",
          selectedFirst: "å·²é¸æ“‡ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦",
          operatorSelected: (op) => `å·²é¸æ“‡ "${op}"ï¼Œè«‹é»æ“Šç¬¬äºŒå¼µå¡`,
          switchedCard: "å·²åˆ‡æ›ç‚ºæ–°çš„ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦",
          canceled: "å·²å–æ¶ˆé¸æ“‡",
          resetHand: "å·²é‡è¨­æ‰‹ç‰Œ",
          noCard: "è«‹å…ˆé¸æ“‡å¡ç‰Œ",
          subtractIdentical: "âŒ ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›ï¼",
          divideByZero: "âŒ ä¸èƒ½é™¤ä»¥é›¶ï¼",
          notDivisible: "âŒ é™¤æ³•çµæœå¿…é ˆç‚ºæ•´æ•¸ï¼",
          negativeResult: "âŒ çµæœä¸èƒ½ç‚ºè² æ•¸ï¼"
        }
      },
      en: {
        gameTitle: "Math Royale",
        scoreLabel: "Score",
        timeLabel: "Time",
        messageStart: "ğŸ¯ Click the first card!",
        hintBtn: "Hint",
        nextBtn: "Next",
        resetBtn: "Reset",
        cancelBtn: "Cancel",
        instructionsTitle: "ğŸ® How to Play",
        instructions: [
          "<strong>ğŸ¯ Goal</strong><br>Use all 5 cards to reach the target value within 60 seconds",
          "<strong>ğŸ® How to Play</strong><br>1ï¸âƒ£ Click the first card<br>2ï¸âƒ£ Choose an operator (+ âˆ’ Ã— Ã·)<br>3ï¸âƒ£ Click the second card â†’ auto-calculate",
          "<strong>âœ… Allowed / âŒ Not Allowed</strong><br>âœ… Use +, âˆ’, Ã—, Ã· freely<br>âœ… Reuse operators as needed<br>âŒ No negative results<br>âŒ Division must be exact (no remainder)<br>âŒ Cannot divide by zero<br>âŒ Cannot subtract two identical cards",
          "<strong>ğŸ† Scoring</strong><br>Success: +100 points<br>Bonus: +10 points per second remaining"
        ],
        startGameBtn: "Start Game!",
        successTimeMessage: (time) => `ğŸ‰ You completed it in ${time} seconds!`,
        successMessages: [
          "You're a math genius!",
          "Amazing! Perfectly correct!",
          "Flawless calculation!",
          "You're the Math Master!",
          "Precise and accurate!",
          "Superb calculation!",
          "You made math look easy!",
          "Perfect solution! Well done!"
        ],
        failureTitle: "ğŸ’ª Try again!",
        failureMessages: [
          "Don't worry, try again!",
          "So close to success!",
          "Keep going, you're great!",
          "Never give up, you'll make it next time!",
          "Learning is all about trying!",
          "You're almost there!",
          "Every mistake is a step forward!",
          "Believe in yourself, you can do it!"
        ],
        shareBtnText: "Share Challenge",
        restartBtnText: "Restart",
        continueBtnText: "Continue",
        volumeBtnTitle: "Toggle Sound",
        messages: {
          cannotSelfOperate: "Cannot operate with itself!",
          selectFirstCard: "Please select the first card first!",
          selectedFirst: "First card selected, please choose an operator",
          operatorSelected: (op) => `Operator "${op}" selected, please click the second card`,
          switchedCard: "Switched to a new first card, please choose an operator",
          canceled: "Selection canceled",
          resetHand: "Hand reset",
          noCard: "Please select a card first",
          subtractIdentical: "âŒ Cannot subtract two identical cards!",
          divideByZero: "âŒ Cannot divide by zero!",
          notDivisible: "âŒ Division result must be an integer!",
          negativeResult: "âŒ Result cannot be negative!"
        }
      }
    };
    let currentLang = 'zh';

    function toggleLanguageInModal() {
      currentLang = currentLang === 'zh' ? 'en' : 'zh';
      updateLanguage();
      const url = new URL(window.location);
      if (currentLang === 'en') {
        url.searchParams.set('lang', 'en');
      } else {
        url.searchParams.delete('lang');
      }
      window.history.replaceState({}, '', url);
    }

    function updateLanguage() {
      const t = translations[currentLang];
      document.getElementById('gameTitle').textContent = t.gameTitle;
      document.getElementById('scoreLabel').textContent = t.scoreLabel;
      document.getElementById('timeLabel').textContent = t.timeLabel;
      document.getElementById('hintBtn').textContent = t.hintBtn;
      document.getElementById('nextBtn').textContent = t.nextBtn;
      document.getElementById('resetBtn').textContent = t.resetBtn;
      document.getElementById('cancelBtn').textContent = t.cancelBtn;
      document.getElementById('volumeBtn').title = t.volumeBtnTitle;
      document.getElementById('instructionsTitle').textContent = t.instructionsTitle;
      const instructionsList = document.getElementById('instructionsList');
      instructionsList.innerHTML = '';
      t.instructions.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = item;
        instructionsList.appendChild(li);
      });
      document.getElementById('startGameBtn').textContent = t.startGameBtn;
      document.getElementById('shareBtnText').textContent = t.shareBtnText;
      document.getElementById('shareBtnText2').textContent = t.shareBtnText;
      document.getElementById('restartBtnText').textContent = t.restartBtnText;
      document.getElementById('restartBtnText2').textContent = t.restartBtnText;
      document.getElementById('continueBtnText').textContent = t.continueBtnText;
      document.getElementById('continueBtnText2').textContent = t.continueBtnText;
      document.getElementById('failureTitle').textContent = t.failureTitle;
      if (!isGameActive) {
        document.getElementById('message').textContent = t.messageStart;
        document.getElementById('message').className = 'message info';
      }
    }

    function parseUrlLanguage() {
      const urlParams = new URLSearchParams(window.location.search);
      const lang = urlParams.get('lang');
      if (lang === 'en') return 'en';
      return 'zh';
    }

    // ===== å…¨åŸŸç‹€æ…‹ =====
    const VALUE_TO_RANK = {1:'A',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K'};
    const SUITS = ['â™ ','â™¥','â™¦','â™£'];
    let currentTarget = null;
    let originalHand = [];
    let selectedCard1 = null;
    let selectedOperator = null;
    let score = 0;
    let combo = 0;
    let timeLeft = 60;
    let timer = null;
    let isGameActive = false;
    let currentStep = 0;
    let currentGameSnapshot = null;
    let lastUsedPattern = -1;
    let generatedPuzzles = new Set();
    let volumeEnabled = true;
    let currentPuzzle = null;

    function getRandomSuit() {
      return SUITS[Math.floor(Math.random() * SUITS.length)];
    }

    function valueToDisplay(value) {
      if (value >= 1 && value <= 13) {
        return VALUE_TO_RANK[value] + getRandomSuit();
      }
      return String(Math.round(value * 100) / 100);
    }

    function createCard(value, isNew = false) {
      const card = document.createElement('div');
      card.className = 'card';
      card.textContent = valueToDisplay(value);
      card.dataset.value = value;
      card.onclick = (e) => {
        e.stopPropagation();
        selectCard(card);
      };
      return card;
    }

    function toggleVolume() {
      volumeEnabled = !volumeEnabled;
      const volumeBtn = document.getElementById('volumeBtn');
      if (volumeEnabled) {
        volumeBtn.textContent = 'ğŸ”Š';
        volumeBtn.classList.remove('muted');
      } else {
        volumeBtn.textContent = 'ğŸ”‡';
        volumeBtn.classList.add('muted');
      }
    }

    function playCalculationSound(operation) {
      if (!volumeEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      let time = 0;
      switch(operation) {
        case '+':
          {
            const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
            o1.frequency.value = 523; g1.gain.value = 0.3;
            o1.connect(g1); g1.connect(ctx.destination);
            o1.start(time); o1.stop(time + 0.2);
            const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
            o2.frequency.value = 587; g2.gain.value = 0.3;
            o2.connect(g2); g2.connect(ctx.destination);
            o2.start(time + 0.2); o2.stop(time + 0.4);
            setTimeout(() => ctx.close(), 450);
            break;
          }
        case 'âˆ’':
          {
            const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
            o1.frequency.value = 587; g1.gain.value = 0.3;
            o1.connect(g1); g1.connect(ctx.destination);
            o1.start(time); o1.stop(time + 0.2);
            const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
            o2.frequency.value = 523; g2.gain.value = 0.3;
            o2.connect(g2); g2.connect(ctx.destination);
            o2.start(time + 0.2); o2.stop(time + 0.4);
            setTimeout(() => ctx.close(), 450);
            break;
          }
        case 'Ã—':
          {
            const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
            o1.frequency.value = 523; g1.gain.value = 0.3;
            o1.connect(g1); g1.connect(ctx.destination);
            o1.start(time); o1.stop(time + 0.2);
            const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
            o2.frequency.value = 659; g2.gain.value = 0.3;
            o2.connect(g2); g2.connect(ctx.destination);
            o2.start(time); o2.stop(time + 0.2);
            const o3 = ctx.createOscillator(); const g3 = ctx.createGain();
            o3.frequency.value = 784; g3.gain.value = 0.3;
            o3.connect(g3); g3.connect(ctx.destination);
            o3.start(time + 0.1); o3.stop(time + 0.3);
            setTimeout(() => ctx.close(), 350);
            break;
          }
        case 'Ã·':
          {
            const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
            o1.frequency.value = 784; g1.gain.value = 0.3;
            o1.connect(g1); g1.connect(ctx.destination);
            o1.start(time); o1.stop(time + 0.15);
            const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
            o2.frequency.value = 1046; g2.gain.value = 0.3;
            o2.connect(g2); g2.connect(ctx.destination);
            o2.start(time + 0.15); o2.stop(time + 0.3);
            setTimeout(() => ctx.close(), 350);
            break;
          }
      }
    }

    function playSuccessSound() {
      if (!volumeEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      const notes = [523, 659, 784, 1046];
      const durations = [0.15, 0.15, 0.15, 0.2];
      let time = 0;
      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = freq;
        gain.gain.value = 0.3;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(time);
        osc.stop(time + durations[i]);
        time += durations[i] + (i === 2 ? 0.15 : 0);
      });
      setTimeout(() => ctx.close(), 650);
    }

    function playFailureSound() {
      if (!volumeEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      const notes = [523, 440, 392];
      const times = [0, 0.2, 0.4];
      const durations = [0.2, 0.2, 0.25];
      notes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = freq;
        gain.gain.value = 0.3;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(times[i]);
        osc.stop(times[i] + durations[i]);
      });
      setTimeout(() => ctx.close(), 700);
    }

    function playReadyGoSound(callback) {
      if (callback) {
        setTimeout(callback, 100);
      }
    }

    function playTenSecondBeep() {
      if (!volumeEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 660;
      gain.gain.value = 0.2;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(0);
      osc.stop(0.15);
      setTimeout(() => ctx.close(), 200);
    }

    function playCountdownVoice(num) {
      if ('speechSynthesis' in window) {
        const words = {5: 'Five', 4: 'Four', 3: 'Three', 2: 'Two', 1: 'One'};
        const word = words[num];
        if (word) {
          const utterance = new SpeechSynthesisUtterance(word);
          utterance.lang = 'en-US';
          utterance.rate = 1.0;
          utterance.volume = 0.8;
          speechSynthesis.speak(utterance);
          return;
        }
      }
      if (!volumeEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      const frequencies = {5: 440, 4: 523, 3: 587, 2: 659, 1: 784};
      const freq = frequencies[num] || 440;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.value = 0.3;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(0);
      osc.stop(0.3);
      setTimeout(() => {
        ctx.close().catch(() => {});
      }, 350);
    }

    function playEncouragementSound() {
      if (!volumeEnabled) return;
      const phrases = ["wonderful", "fantastic", "great", "Excellent", "Amazing"];
      const phrase = phrases[Math.floor(Math.random() * phrases.length)];
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(phrase);
        utterance.lang = 'en-US';
        utterance.rate = 1.0;
        utterance.pitch = 1.2;
        utterance.volume = 0.9;
        speechSynthesis.speak(utterance);
        return;
      }
      if (!window.AudioContext && !window.webkitAudioContext) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();
      const notes = [523, 659, 784];
      let time = 0;
      for (let i = 0; i < notes.length; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = notes[i];
        gain.gain.value = 0.25;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(time + i * 0.1);
        osc.stop(time + i * 0.1 + 0.12);
      }
      setTimeout(() => ctx.close(), 350);
    }

    function startTimer() {
      if (timer) clearInterval(timer);
      timeLeft = 60;
      isGameActive = true;
      updateTimerUI();
      timer = setInterval(() => {
        if (!isGameActive || currentTarget === null) {
          clearInterval(timer);
          timer = null;
          return;
        }
        timeLeft--;
        updateTimerUI();
        if (timeLeft > 5 && timeLeft % 10 === 0) {
          playTenSecondBeep();
        }
        if (timeLeft >= 1 && timeLeft <= 5) {
          playCountdownVoice(timeLeft);
        }
        if (timeLeft <= 0) {
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          if (currentTarget !== null && originalHand.length > 0) {
            showFailureScreen();
          }
        }
      }, 1000);
    }

    function updateTimerUI() {
      document.getElementById('timeLeft').textContent = timeLeft;
      const fill = document.getElementById('timerFill');
      if (fill) {
        const percent = Math.max(0, timeLeft / 60 * 100);
        fill.style.width = percent + '%';
        if (timeLeft <= 18) {
          fill.style.background = '#d63031';
        } else {
          fill.style.background = '#0984e3';
        }
      }
    }

    function addScore(base, timeBonus = 0, isCombo = false) {
      let total = base + timeBonus;
      if (isCombo && combo > 1) {
        total = Math.floor(total * (1 + (combo - 1) * 0.2));
      }
      score += total;
      document.getElementById('score').textContent = score;
    }

    function selectCard(card) {
      if (!isGameActive) return;
      if (selectedOperator !== null) {
        if (card === selectedCard1) {
          showMessage(translations[currentLang].messages.cannotSelfOperate, 'error');
          return;
        }
        performCalculation(card);
        return;
      }
      if (selectedCard1 === null) {
        selectedCard1 = card;
        card.classList.add('selected-first');
        document.getElementById('operatorMenu').style.display = 'flex';
        showMessage(translations[currentLang].messages.selectedFirst, 'info');
      } else if (card === selectedCard1) {
        clearSelection();
        showMessage(translations[currentLang].messages.canceled, 'info');
      } else {
        selectedCard1.classList.remove('selected-first');
        selectedCard1 = card;
        card.classList.add('selected-first');
        showMessage(translations[currentLang].messages.switchedCard, 'info');
      }
    }

    function selectOperator(op) {
      if (selectedCard1 === null || !isGameActive) {
        showMessage(translations[currentLang].messages.selectFirstCard, 'error');
        return;
      }
      selectedOperator = op;
      showMessage(translations[currentLang].messages.operatorSelected(op), 'info');
      playCalculationSound(op);
    }

    function performCalculation(secondCard) {
      const val1 = parseFloat(selectedCard1.dataset.value);
      const val2 = parseFloat(secondCard.dataset.value);
      let result;
      switch(selectedOperator) {
        case '+':
          result = val1 + val2;
          break;
        case 'âˆ’':
          if (Math.abs(val1 - val2) < 1e-9) {
            showMessage(translations[currentLang].messages.subtractIdentical, 'error');
            clearSelection();
            return;
          }
          result = val1 - val2;
          break;
        case 'Ã—':
          result = val1 * val2;
          break;
        case 'Ã·':
          if (Math.abs(val2) < 1e-9) {
            showMessage(translations[currentLang].messages.divideByZero, 'error');
            clearSelection();
            return;
          }
          if (Math.abs(val1 % val2) > 1e-9) {
            showMessage(translations[currentLang].messages.notDivisible, 'error');
            clearSelection();
            return;
          }
          result = val1 / val2;
          break;
        default:
          clearSelection();
          return;
      }
      if (result < 0) {
        showMessage(translations[currentLang].messages.negativeResult, 'error');
        clearSelection();
        return;
      }
      selectedCard1.remove();
      secondCard.remove();
      const newCard = createCard(result, true);
      document.getElementById('handArea').appendChild(newCard);
      clearSelection();
      currentStep++;
      const remainingCardsAfter = document.querySelectorAll('.card').length;
      if (remainingCardsAfter > 1) {
        playEncouragementSound();
      }
      if (remainingCardsAfter === 1) {
        const finalValue = parseFloat(document.querySelector('.card').dataset.value);
        if (Math.abs(finalValue - currentTarget) < 1e-6) {
          const timeBonus = timeLeft * 10;
          combo++;
          addScore(100, timeBonus, true);
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          showSuccessScreen();
        } else {
          combo = 0;
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          showFailureScreen();
        }
      }
    }

    function cancelSelection() {
      clearSelection();
      showMessage(translations[currentLang].messages.canceled, 'info');
    }

    function clearSelection() {
      if (selectedCard1) {
        selectedCard1.classList.remove('selected-first');
        selectedCard1 = null;
      }
      selectedOperator = null;
      document.getElementById('operatorMenu').style.display = 'none';
    }

    function resetHand() {
      if (!isGameActive) return;
      clearSelection();
      const handArea = document.getElementById('handArea');
      handArea.innerHTML = '';
      for (let i = 0; i < originalHand.length; i++) {
        handArea.appendChild(createCard(originalHand[i]));
      }
      currentStep = 0;
      startTimer();
      showMessage(translations[currentLang].messages.resetHand, 'info');
    }

    function showHint() {
      const cards = Array.from(document.querySelectorAll('.card')).map(card =>
        parseFloat(card.dataset.value)
      );
      if (cards.length === 0) {
        return translations[currentLang].messages.noCard;
      }
      const sortedCards = [...cards].sort((a, b) => a - b);
      const target = currentTarget;
      const hints = {
        zh: {
          step1: {
            hasOne: "æœ‰1çš„è©±ï¼Œå…ˆç”¨1å’Œå…¶ä»–æ•¸å­—ç›¸åŠ ",
            smallNumbers: "å…ˆåˆä½µå…©å€‹å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰",
            bigNumbers: "æœ‰å¤§æ•¸å­—ï¼ˆâ‰¥10ï¼‰æ™‚ï¼Œè€ƒæ…®ç”¨æ¸›æ³•æˆ–é™¤æ³•",
            default: "å°‹æ‰¾å¯ä»¥æ•´é™¤çš„æ•¸å­—å°"
          },
          step2: {
            bigNumbers: "å¤§æ•¸å­—ï¼ˆ>10ï¼‰å»ºè­°ç”¨æ¸›æ³•æˆ–é™¤æ³•",
            hasOne: "1å¯ä»¥ç”¨ä¾†å¾®èª¿çµæœ",
            smallNumbers: "å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰é©åˆç”¨ä¾†èª¿æ•´çµæœ",
            factor: "å°‹æ‰¾ç›®æ¨™å€¼çš„å› æ•¸",
            default: "å˜—è©¦è£½é€ ç›®æ¨™å€¼çš„å› æ•¸"
          },
          step3: {
            sumEquals: "æ‰€æœ‰æ•¸å­—ç›¸åŠ ç­‰æ–¼ç›®æ¨™ï¼",
            sumClose: "ç¸½å’Œæ¥è¿‘ç›®æ¨™ï¼Œèª¿æ•´é‹ç®—ç¬¦",
            adjustWithSmall: "ç”¨å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰ä¾†å¾®èª¿çµæœ",
            halfOrThird: "æœ‰æ•¸å­—æ˜¯ç›®æ¨™å€¼çš„ä¸€åŠæˆ–ä¸‰åˆ†ä¹‹ä¸€",
            default: "æª¢æŸ¥æ˜¯å¦èƒ½ç”¨ä¹˜æ³•å¿«é€Ÿæ¥è¿‘ç›®æ¨™"
          },
          step4: {
            add: "ç”¨åŠ æ³•ï¼",
            subtract: "ç”¨æ¸›æ³•ï¼",
            multiply: "ç”¨ä¹˜æ³•ï¼",
            divide: "ç”¨é™¤æ³•ï¼",
            divideSwap: "ç”¨é™¤æ³•ï¼ˆäº¤æ›é †åºï¼‰ï¼",
            default: "åªå‰©å…©å¼µå¡ï¼Œè©¦è©¦æ‰€æœ‰é‹ç®—ç¬¦ï¼"
          },
          final: "é€™æ˜¯æœ€å¾Œä¸€æ­¥ï¼Œä»”ç´°è¨ˆç®—ï¼",
          normal: "æ­£å¸¸é€²è¡ŒéŠæˆ²"
        },
        en: {
          step1: {
            hasOne: "If you have a 1, add it to another number first",
            smallNumbers: "Combine two small numbers (â‰¤7) first",
            bigNumbers: "For large numbers (â‰¥10), consider subtraction or division",
            default: "Look for pairs that can be evenly divided"
          },
          step2: {
            bigNumbers: "For large numbers (>10), prefer subtraction or division",
            hasOne: "Use 1 to fine-tune the result",
            smallNumbers: "Small numbers (â‰¤7) are good for adjustments",
            factor: "Look for factors of the target value",
            default: "Try to create factors of the target"
          },
          step3: {
            sumEquals: "The sum of all cards equals the target!",
            sumClose: "The total is close to the target, adjust operators",
            adjustWithSmall: "Use small numbers (â‰¤7) to fine-tune the result",
            halfOrThird: "You have a number that is half or one-third of the target",
            default: "Check if multiplication can quickly get close to the target"
          },
          step4: {
            add: "Use addition!",
            subtract: "Use subtraction!",
            multiply: "Use multiplication!",
            divide: "Use division!",
            divideSwap: "Use division (swap order)!",
            default: "Only two cards left, try all operators!"
          },
          final: "This is the final step, calculate carefully!",
          normal: "Proceed normally"
        }
      };
      const t = hints[currentLang];
      switch(currentStep + 1) {
        case 1:
          if (sortedCards.includes(1)) return t.step1.hasOne;
          if (sortedCards.some(x => x <= 7)) return t.step1.smallNumbers;
          if (sortedCards.some(x => x >= 10)) return t.step1.bigNumbers;
          return t.step1.default;
        case 2:
          if (sortedCards.some(x => x > 10)) return t.step2.bigNumbers;
          if (sortedCards.some(x => x === 1)) return t.step2.hasOne;
          if (sortedCards.some(x => x <= 7)) return t.step2.smallNumbers;
          if (target && sortedCards.some(x => target % x === 0)) return t.step2.factor;
          return t.step2.default;
        case 3:
          if (target && sortedCards.length >= 2) {
            const sum = sortedCards.reduce((a, b) => a + b, 0);
            if (sum === target) return t.step3.sumEquals;
            if (Math.abs(sum - target) <= 2) return t.step3.sumClose;
            if (sortedCards.some(x => x <= 7 && (target - x >= 0))) return t.step3.adjustWithSmall;
            if (sortedCards.some(x => x * 2 === target || x * 3 === target)) return t.step3.halfOrThird;
          }
          return t.step3.default;
        case 4:
          if (sortedCards.length === 2) {
            const [a, b] = sortedCards;
            const target = currentTarget;
            if (target) {
              if (a + b === target) return t.step4.add;
              if (Math.abs(a - b) === target) return t.step4.subtract;
              if (a * b === target) return t.step4.multiply;
              if (b !== 0 && a % b === 0 && a / b === target) return t.step4.divide;
              if (a !== 0 && b % a === 0 && b / a === target) return t.step4.divideSwap;
            }
            return t.step4.default;
          }
          return t.final;
        default:
          return t.normal;
      }
    }

    function showMessage(text, type) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.className = 'message ' + type;
    }

    function showSuccessScreen() {
      playSuccessSound();
      const usedTime = 60 - timeLeft;
      const t = translations[currentLang];
      document.getElementById('successTimeMessage').textContent = t.successTimeMessage(usedTime);
      const randomMessage = t.successMessages[Math.floor(Math.random() * t.successMessages.length)];
      document.getElementById('successMessage').textContent = randomMessage;
      document.getElementById('successModal').style.display = 'flex';
    }

    function showFailureScreen() {
      playFailureSound();
      const t = translations[currentLang];
      const randomMessage = t.failureMessages[Math.floor(Math.random() * t.failureMessages.length)];
      document.getElementById('failureMessage').textContent = randomMessage;
      document.getElementById('failureModal').style.display = 'flex';
    }

    const SOLUTION_PATTERNS = [
      {
        name: 'target_one',
        generate: () => {
          const a = Math.floor(Math.random() * 13) + 1;
          const ops = [a, a, 1, 1, 1];
          return { ops, target: 1 };
        }
      },
      {
        name: 'target_two',
        generate: () => {
          const a = Math.floor(Math.random() * 6) + 2;
          const ops = [a, a, a, 1, 1];
          return { ops, target: 2 };
        }
      },
      {
        name: 'small_target',
        generate: () => {
          const a = Math.floor(Math.random() * 7) + 1;
          const b = Math.floor(Math.random() * 7) + 1;
          const c = Math.floor(Math.random() * 7) + 1;
          const d = 1;
          const e = 1;
          const ops = [a, b, c, d, e].sort(() => Math.random() - 0.5);
          const target = Math.max(3, Math.min(7, a + b + c - d - e));
          return { ops, target };
        }
      },
      {
        name: 'big_target',
        generate: () => {
          const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 8);
          const sum = ops.reduce((a, b) => a + b, 0);
          const target = Math.max(8, Math.min(13, sum - Math.floor(Math.random() * 5)));
          return { ops, target };
        }
      }
    ];

    function isValidPuzzle(puzzle) {
      if (!puzzle.ops.every(x => x >= 1 && x <= 13)) return false;
      if (puzzle.target < 1 || puzzle.target > 13) return false;
      const sum = puzzle.ops.reduce((a, b) => a + b, 0);
      const minPossible = Math.max(1, puzzle.ops.reduce((a, b) => Math.min(a, b), 13));
      if (sum < puzzle.target) return false;
      if (minPossible > puzzle.target && puzzle.ops.length > 1) return false;
      if (puzzle.ops.every(x => x === 1) && puzzle.target !== 5) return false;
      return true;
    }

    function parseUrlPuzzle() {
      try {
        const urlParams = new URLSearchParams(window.location.search);
        const handParam = urlParams.get('hand');
        const targetParam = urlParams.get('target');
        if (!handParam || !targetParam) return null;
        const hand = handParam.split(',').map(str => {
          const num = parseInt(str.trim(), 10);
          if (isNaN(num) || num < 1 || num > 13) throw new Error('Invalid card value');
          return num;
        });
        if (hand.length !== 5) throw new Error('Must have exactly 5 cards');
        const target = parseInt(targetParam.trim(), 10);
        if (isNaN(target) || target < 1 || target > 13) throw new Error('Invalid target value');
        if (!isValidPuzzle({ ops: hand, target })) throw new Error('Invalid puzzle combination');
        return { hand, target };
      } catch (e) {
        console.warn('URL puzzle parsing failed:', e.message);
        return null;
      }
    }

    function generateUniquePuzzle() {
      let attempts = 0;
      const maxAttempts = 100;
      while (attempts < maxAttempts) {
        const isSmallTarget = Math.random() < 0.65;
        const targetRange = isSmallTarget ? [1, 7] : [8, 13];
        const smallPatterns = ['target_one', 'target_two', 'small_target'];
        const bigPatterns = ['big_target'];
        const availablePatterns = isSmallTarget ? smallPatterns : bigPatterns;
        const patternName = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
        const pattern = SOLUTION_PATTERNS.find(p => p.name === patternName);
        try {
          const puzzle = pattern.generate();
          if (puzzle.target >= targetRange[0] && puzzle.target <= targetRange[1]) {
            if (isValidPuzzle(puzzle)) {
              const signature = getPuzzleSignature(puzzle);
              if (!generatedPuzzles.has(signature)) {
                generatedPuzzles.add(signature);
                return puzzle;
              }
            }
          }
        } catch (e) {}
        attempts++;
      }
      const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 7) + 1);
      const target = Math.max(1, Math.min(7, ops.reduce((a, b) => a + b, 0) - 3));
      return { ops, target };
    }

    function getPuzzleSignature(puzzle) {
      const sortedOps = [...puzzle.ops].sort((a, b) => a - b);
      return sortedOps.join(',') + '|' + puzzle.target;
    }

    function loadNewGame(useSnapshot = false) {
      combo = 0;
      currentStep = 0;
      let puzzle = null;
      if (useSnapshot && currentGameSnapshot) {
        puzzle = {
          ops: [...currentGameSnapshot.hand],
          target: currentGameSnapshot.target
        };
      } else {
        puzzle = generateUniquePuzzle();
      }
      const { ops: hand, target } = puzzle;
      currentTarget = target;
      originalHand = [...hand];
      currentPuzzle = {
        hand: [...hand],
        target: target
      };
      currentGameSnapshot = {
        target: currentTarget,
        hand: [...originalHand],
        score: score,
        timeLeft: timeLeft
      };
    }

    function newGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      loadNewGame();
      playReadyGoSound(() => {
        document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
        const handArea = document.getElementById('handArea');
        handArea.innerHTML = '';
        for (let i = 0; i < originalHand.length; i++) {
          handArea.appendChild(createCard(originalHand[i]));
        }
        startTimer();
      });
    }

    async function shareChallenge() {
      if (!currentPuzzle) {
        alert(translations[currentLang].messages.noCard);
        return;
      }
      const { hand, target } = currentPuzzle;
      const cardsStr = hand.join(',');
      const baseUrl = window.location.href.split('?')[0];
      let urlWithParams = `${baseUrl}?hand=${cardsStr}&target=${target}`;
      if (currentLang === 'en') {
        urlWithParams += '&lang=en';
      }
      const shareText = currentLang === 'en'
        ? `ã€Math Royale Challengeã€‘Use ${cardsStr} to make ${target}! Can you solve it? ğŸ‘‰ ${urlWithParams}`
        : `ã€Math Royale æŒ‘æˆ°ã€‘ç”¨ ${cardsStr} ç®—å‡º ${target}ï¼ä½ èƒ½è§£é–‹å—ï¼ŸğŸ‘‰ ${urlWithParams}`;
      try {
        await navigator.clipboard.writeText(shareText);
        const t = translations[currentLang];
        showMessage(t.lang === 'en' ? 'âœ… Copied! Share with friends!' : 'âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
      } catch (err) {
        const textArea = document.createElement('textarea');
        textArea.value = shareText;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();
        try {
          const success = document.execCommand('copy');
          if (success) {
            const t = translations[currentLang];
            showMessage(t.lang === 'en' ? 'âœ… Copied! Share with friends!' : 'âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
          } else {
            showMessage(currentLang === 'en' ? 'Please copy manually:\n' + shareText : 'è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
          }
        } catch (e) {
          showMessage(currentLang === 'en' ? 'Please copy manually:\n' + shareText : 'è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
        }
        document.body.removeChild(textArea);
      }
      setTimeout(() => {
        const msg = document.getElementById('message');
        if (msg.textContent.includes('âœ…')) {
          msg.textContent = translations[currentLang].messageStart;
          msg.className = 'message info';
        }
      }, 3000);
    }

    function startGameFromInstructions() {
      document.getElementById('instructionsModal').style.display = 'none';
      if (currentGameSnapshot && currentGameSnapshot.hand && currentGameSnapshot.target) {
        currentTarget = currentGameSnapshot.target;
        originalHand = [...currentGameSnapshot.hand];
        currentPuzzle = { hand: [...originalHand], target: currentTarget };
      } else {
        loadNewGame();
      }
      playReadyGoSound(() => {
        document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
        const handArea = document.getElementById('handArea');
        handArea.innerHTML = '';
        for (let i = 0; i < originalHand.length; i++) {
          handArea.appendChild(createCard(originalHand[i]));
        }
        startTimer();
      });
    }

    function closeInstructions() {
      alert(currentLang === 'en' ? 'Please click "Start Game!" button to begin.' : 'è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
    }

    window.onclick = function(event) {
      const modal = document.getElementById('instructionsModal');
      if (event.target === modal) {
        alert(currentLang === 'en' ? 'Please click "Start Game!" button to begin.' : 'è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
      }
    }

    function restartGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      document.getElementById('handArea').innerHTML = '';
      document.getElementById('targetCard').textContent = '?';
      showMessage(translations[currentLang].messageStart, 'info');
      if (currentGameSnapshot) {
        currentTarget = currentGameSnapshot.target;
        originalHand = [...currentGameSnapshot.hand];
        score = currentGameSnapshot.score;
        timeLeft = currentGameSnapshot.timeLeft;
        document.getElementById('score').textContent = score;
        document.getElementById('timeLeft').textContent = timeLeft;
      } else {
        score = 0;
        combo = 0;
        currentStep = 0;
        timeLeft = 60;
        document.getElementById('score').textContent = '0';
        document.getElementById('timeLeft').textContent = '60';
      }
      playReadyGoSound(() => {
        document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
        const handArea = document.getElementById('handArea');
        handArea.innerHTML = '';
        for (let i = 0; i < originalHand.length; i++) {
          handArea.appendChild(createCard(originalHand[i]));
        }
        startTimer();
      });
    }

    function continueChallenge() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      currentTarget = null;
      originalHand = [];
      score = 0;
      combo = 0;
      currentStep = 0;
      isGameActive = false;
      timeLeft = 60;
      document.getElementById('score').textContent = '0';
      document.getElementById('timeLeft').textContent = '60';
      document.getElementById('message').textContent = translations[currentLang].messageStart;
      document.getElementById('message').className = 'message info';
      document.getElementById('handArea').innerHTML = '';
      document.getElementById('targetCard').textContent = '?';
      playReadyGoSound(() => {
        loadNewGame();
        document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
        const handArea = document.getElementById('handArea');
        handArea.innerHTML = '';
        for (let i = 0; i < originalHand.length; i++) {
          handArea.appendChild(createCard(originalHand[i]));
        }
        startTimer();
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      currentLang = parseUrlLanguage();
      currentTarget = null;
      originalHand = [];
      score = 0;
      combo = 0;
      currentStep = 0;
      isGameActive = false;
      timeLeft = 60;
      timer = null;
      currentGameSnapshot = null;
      volumeEnabled = true;
      currentPuzzle = null;
      document.getElementById('score').textContent = '0';
      document.getElementById('timeLeft').textContent = '60';
      document.getElementById('targetCard').textContent = '?';
      document.getElementById('handArea').innerHTML = '';
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      const urlPuzzle = parseUrlPuzzle();
      if (urlPuzzle) {
        currentGameSnapshot = {
          target: urlPuzzle.target,
          hand: [...urlPuzzle.hand],
          score: 0,
          timeLeft: 60
        };
      }
      updateLanguage();
      document.getElementById('instructionsModal').style.display = 'flex';
    });

    // è¦†è“‹é ‚éƒ¨æŒ‰éˆ•è¡Œç‚º
    document.getElementById('helpBtn').addEventListener('click', () => {
      document.getElementById('instructionsModal').style.display = 'flex';
    });
  </script>
</body>
</html>
