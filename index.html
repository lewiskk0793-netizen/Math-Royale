<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>Math Royale</title>
<style>
* {
box-sizing: border-box;
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
background: #f0f5ff;
margin: 0;
padding: 16px 0;
color: #333;
min-height: 100vh;
display: block;
}
.container {
width: 95%;
max-width: 800px;
background: white;
padding: 16px;
border-radius: 16px;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
margin: 0 auto;
}
h1 {
text-align: center;
color: #2c3e50;
margin-top: 0;
font-size: 24px;
}
.score-time {
display: flex;
justify-content: space-between;
margin-bottom: 16px;
font-weight: bold;
align-items: center;
font-size: 16px;
}
.timer-bar {
height: 8px;
background: #e0e0e0;
border-radius: 4px;
overflow: hidden;
margin-top: 6px;
}
.timer-fill {
height: 100%;
background: #0984e3;
width: 100%;
transition: width 0.1s linear;
}
.target-row {
display: flex;
justify-content: center;
margin: 16px 0;
}
.target-card {
width: 60px;
height: 80px;
border: 3px solid #d63031;
border-radius: 10px;
display: flex;
align-items: center;
justify-content: center;
font-size: 18px;
font-weight: bold;
background: #ffeaa7;
}
.hand-area {
min-height: 110px;
height: 110px;
max-height: 110px;
margin: 16px 0;
padding: 0 8px;
background: #fafafa;
border-radius: 12px;
display: flex;
flex-wrap: nowrap;
gap: 10px;
justify-content: center;
align-items: center;
overflow-x: hidden;
overflow-y: hidden;
}
.card {
width: calc(16vw - 12px);
min-width: 50px;
max-width: 60px;
flex-shrink: 0;
height: 80px;
border: 3px solid #333;
border-radius: 10px;
display: flex;
align-items: center;
justify-content: center;
font-size: 16px;
font-weight: bold;
background: white;
cursor: pointer;
-webkit-tap-highlight-color: transparent;
transition: all 0.2s;
}
.card.selected-first {
border-color: #0984e3;
transform: scale(1.08);
box-shadow: 0 0 16px rgba(9, 132, 227, 0.6);
}
.operator-menu {
display: none;
justify-content: center;
gap: 14px;
margin: 16px 0;
flex-wrap: wrap;
height: 60px;
}
.op-btn {
width: 50px;
height: 50px;
font-size: 22px;
font-weight: bold;
border: none;
border-radius: 50%;
background: #0984e3;
color: white;
cursor: pointer;
}
.cancel-btn {
padding: 8px 16px;
background: #ff7675;
color: white;
border: none;
border-radius: 8px;
cursor: pointer;
font-weight: bold;
font-size: 14px;
}
.buttons {
display: flex;
gap: 12px;
flex-wrap: wrap;
justify-content: center;
margin: 20px 0;
}
button {
padding: 10px 16px;
font-size: 16px;
border: none;
border-radius: 10px;
cursor: pointer;
background: #0984e3;
color: white;
font-weight: bold;
}
#hintBtn { background: #00b894; }
#nextBtn { background: #fdcb6e; color: #2d3436; }
#resetBtn { background: #a29bfe; }
#volumeBtn { background: #6c5ce7; color: white; }
#volumeBtn.muted { background: #636e72; color: #dfe6e9; }
.message {
margin-top: 16px;
padding: 12px;
border-radius: 10px;
font-weight: bold;
text-align: center;
font-size: 14px;
}
.success { background: #d5f4e6; color: #00a86b; }
.error { background: #ffdddd; color: #d63031; }
.info { background: #e3f2fd; color: #0984e3; }
/* Modal é€šç”¨ */
.modal,
#successModal,
#failureModal,
#instructionsModal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0,0,0,0.6);
overflow: auto;
justify-content: center;
align-items: center;
}
/* æˆåŠŸ/å¤±æ•—å½ˆçª— */
#successModal .modal-content,
#failureModal .modal-content {
display: inline-block;
background: white;
padding: 16px;
border-radius: 12px;
text-align: center;
box-shadow: 0 6px 24px rgba(0,0,0,0.3);
min-width: 280px;
max-width: 90vw;
font-size: 15px;
}
#successModal .modal-content {
background: #d5f4e6;
border: 2px solid #00a86b;
}
#successTimeMessage {
color: #00a86b;
margin-top: 0;
margin-bottom: 8px;
font-size: 18px;
}
#successMessage {
font-size: 14px;
margin: 10px 0;
color: #006400;
}
#failureModal .modal-content {
background: #ffebee;
border: 2px solid #d63031;
}
#failureModal h2 {
color: #d63031;
margin-top: 0;
margin-bottom: 16px;
font-size: 20px;
}
#failureMessage {
font-size: 16px;
margin: 16px 0;
color: #8B0000;
}
/* ===== ç©æ³•èªªæ˜å½ˆçª—æ¨£å¼ï¼ˆç™½è‰²èƒŒæ™¯ï¼‰===== */
#instructionsModal .modal-content {
background: white;
padding: 20px;
border-radius: 12px;
text-align: left;
max-width: 90vw;
max-height: 80vh;
overflow-y: auto;
box-shadow: 0 6px 24px rgba(0,0,0,0.3);
}
#instructionsModal .close {
float: right;
font-size: 24px;
font-weight: bold;
cursor: pointer;
color: #aaa;
}
#instructionsModal .close:hover {
color: #000;
}
.action-buttons {
display: flex;
gap: 10px;
margin-top: 20px;
width: 100%;
}
.action-btn {
flex: 1;
padding: 10px 6px;
border: none;
border-radius: 8px;
font-size: 14px;
font-weight: bold;
cursor: pointer;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 60px;
}
.btn-icon {
font-size: 20px;
margin-bottom: 4px;
display: block;
}
.restart-btn {
background: #6c5ce7;
color: white;
}
.continue-btn {
background: #00a86b;
color: white;
}
#failureModal .continue-btn {
background: #d63031;
}
/* åˆ†äº«æŒ‰éˆ•æ¨£å¼ */
.share-btn {
background: #e17055;
color: white;
border: none;
border-radius: 8px;
padding: 10px;
font-size: 14px;
font-weight: bold;
cursor: pointer;
margin-top: 12px;
display: flex;
align-items: center;
justify-content: center;
gap: 6px;
width: 100%;
}
.share-btn:hover {
background: #d63031;
}
</style>
</head>
<body>
<div class="container">
<h1>Math Royale</h1>
<div class="score-time">
<div>ğŸ† åˆ†æ•¸: <span id="score">0</span></div>
<div>â±ï¸ æ™‚é–“: <span id="timeLeft">60</span>s</div>
</div>
<div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
<div class="target-row">
<div class="target-card" id="targetCard">?</div>
</div>
<div class="hand-area" id="handArea"></div>
<div class="operator-menu" id="operatorMenu">
<button class="op-btn" onclick="selectOperator('+')">+</button>
<button class="op-btn" onclick="selectOperator('âˆ’')">âˆ’</button>
<button class="op-btn" onclick="selectOperator('Ã—')">Ã—</button>
<button class="op-btn" onclick="selectOperator('Ã·')">Ã·</button>
<button class="cancel-btn" onclick="cancelSelection()">å–æ¶ˆ</button>
</div>
<div class="buttons">
<button id="hintBtn" onclick="showHint()">æç¤º</button>
<button id="nextBtn" onclick="newGame()">æ›ä¸€é¡Œ</button>
<button id="resetBtn" onclick="resetHand()">é‡ä¾†</button>
<button id="volumeBtn" onclick="toggleVolume()" title="é–‹é—œéŸ³æ•ˆ">ğŸ”Š</button>
</div>
<div id="message" class="message info">ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼</div>
</div>

<!-- ç©æ³•èªªæ˜å½ˆçª— -->
<div id="instructionsModal" class="modal">
<div class="modal-content">
<span class="close" onclick="closeInstructions()">&times;</span>
<div class="instructions">
<h2>ğŸ® ç©æ³•èªªæ˜</h2>
<ul>
<li><strong>ç›®æ¨™</strong>ï¼šåœ¨ 60 ç§’å…§ç”¨ 5 å¼µç‰Œç®—å‡ºç›®æ¨™å€¼</li>
<li><strong>æ“ä½œ</strong>ï¼š
<br>1. é»æ“Šç¬¬ä¸€å¼µå¡
<br>2. é¸æ“‡é‹ç®—ç¬¦
<br>3. é»æ“Šç¬¬äºŒå¼µå¡ â†’ è‡ªå‹•è¨ˆç®—
</li>
<li><strong>è¦å‰‡</strong>ï¼š
<br>â€¢ ä¸èƒ½ç”¢ç”Ÿè² æ•¸
<br>â€¢ é™¤æ³•å¿…é ˆæ•´é™¤ï¼ˆç„¡é¤˜æ•¸ï¼‰
<br>â€¢ ä¸èƒ½é™¤ä»¥é›¶
<br>â€¢ <strong>ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›</strong>
</li>
<li><strong>è¨ˆåˆ†</strong>ï¼šæˆåŠŸ +100 åˆ† + å‰©é¤˜æ™‚é–“ Ã— 10 åˆ†</li>
</ul>
<p style="text-align:center; margin-top:16px;">
<button onclick="startGameFromInstructions()" style="padding:8px 16px; background:#0984e3; color:white; border:none; border-radius:6px;">
é–‹å§‹éŠæˆ²ï¼
</button>
</p>
</div>
</div>
</div>

<!-- æˆåŠŸå½ˆå‡ºç•«é¢ -->
<div id="successModal">
<div class="modal-content">
<h2 id="successTimeMessage">ğŸ‰ ä½ èŠ±äº† X ç§’å®Œæˆï¼</h2>
<p id="successMessage"></p>
<button class="share-btn" onclick="shareChallenge()">
<span>ğŸ“¤</span>
<span>åˆ†äº«æŒ‘æˆ°</span>
</button>
<div class="action-buttons">
<button class="action-btn restart-btn" onclick="restartGame()">
<span class="btn-icon">ğŸ”„</span>
<span>é‡æ–°é–‹å§‹</span>
</button>
<button class="action-btn continue-btn" onclick="continueChallenge()">
<span class="btn-icon">âš¡</span>
<span>ç¹¼çºŒæŒ‘æˆ°</span>
</button>
</div>
</div>
</div>

<!-- å¤±æ•—å½ˆå‡ºç•«é¢ -->
<div id="failureModal">
<div class="modal-content">
<h2>ğŸ’ª å†è©¦ä¸€æ¬¡ï¼</h2>
<p id="failureMessage"></p>
<button class="share-btn" onclick="shareChallenge()">
<span>ğŸ“¤</span>
<span>åˆ†äº«æŒ‘æˆ°</span>
</button>
<div class="action-buttons">
<button class="action-btn restart-btn" onclick="restartGame()">
<span class="btn-icon">ğŸ”„</span>
<span>é‡æ–°é–‹å§‹</span>
</button>
<button class="action-btn continue-btn" onclick="continueChallenge()">
<span class="btn-icon">âš¡</span>
<span>ç¹¼çºŒæŒ‘æˆ°</span>
</button>
</div>
</div>
</div>

<script>
// ===== å…¨åŸŸç‹€æ…‹ =====
const VALUE_TO_RANK = {1:'A',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K'};
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
let currentTarget = null;
let originalHand = [];
let selectedCard1 = null;
let selectedOperator = null;
let score = 0;
let combo = 0;
let timeLeft = 60;
let timer = null;
let isGameActive = false;
let currentStep = 0;
let currentGameSnapshot = null;
let lastUsedPattern = -1;
let generatedPuzzles = new Set();
let volumeEnabled = true;
let audioContext = null;
let currentPuzzle = null;

// ===== å·¥å…·å‡½æ•¸ =====
function getRandomSuit() {
return SUITS[Math.floor(Math.random() * SUITS.length)];
}
function valueToDisplay(value) {
if (value >= 1 && value <= 13) {
return VALUE_TO_RANK[value] + getRandomSuit();
}
return String(Math.round(value * 100) / 100);
}
function createCard(value, isNew = false) {
const card = document.createElement('div');
card.className = 'card';
card.textContent = valueToDisplay(value);
card.dataset.value = value;
card.onclick = (e) => {
e.stopPropagation();
selectCard(card);
};
return card;
}

// ===== éŸ³é‡æ§åˆ¶ =====
function toggleVolume() {
volumeEnabled = !volumeEnabled;
const volumeBtn = document.getElementById('volumeBtn');
if (volumeEnabled) {
volumeBtn.textContent = 'ğŸ”Š';
volumeBtn.classList.remove('muted');
} else {
volumeBtn.textContent = 'ğŸ”‡';
volumeBtn.classList.add('muted');
}
}

// ===== æ’­æ”¾å–®éŸ³ =====
function playTone(frequency, duration = 0.2, startTime = 0) {
if (!volumeEnabled || !audioContext) return;
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.type = 'sine';
oscillator.frequency.value = frequency;
gainNode.gain.value = 0.3;
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
const actualStartTime = audioContext.currentTime + startTime;
oscillator.start(actualStartTime);
oscillator.stop(actualStartTime + duration);
}

// ===== è¨ˆç®—éŸ³æ•ˆï¼ˆé»æ“Šé‹ç®—ç¬¦æ™‚ï¼‰=====
function playCalculationSound(operation) {
if (!volumeEnabled) return;
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
switch(operation) {
case '+':
playTone(523, 0.2, 0);
playTone(587, 0.2, 0.2);
break;
case 'âˆ’':
playTone(587, 0.2, 0);
playTone(523, 0.2, 0.2);
break;
case 'Ã—':
playTone(523, 0.2, 0);
playTone(659, 0.2, 0);
playTone(784, 0.2, 0.1);
break;
case 'Ã·':
playTone(784, 0.15, 0);
playTone(1046, 0.15, 0.15);
break;
}
}

// ===== æˆåŠŸ/å¤±æ•—éŸ³æ•ˆ =====
function playSuccessSound() {
if (!volumeEnabled) return;
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
playTone(523, 0.15, 0);
playTone(659, 0.15, 0.15);
playTone(784, 0.15, 0.3);
playTone(1046, 0.2, 0.45);
}
function playFailureSound() {
if (!volumeEnabled) return;
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
playTone(523, 0.2, 0);
playTone(440, 0.2, 0.2);
playTone(392, 0.25, 0.4);
}

// ===== Ready? Go! éŸ³æ•ˆï¼ˆé—œéµä¿®æ­£ï¼šåŒæ­¥å®‰æ’ï¼Œé¿å… setTimeout å»ºç«‹ oscillatorï¼‰=====
function playReadyGoSound(callback) {
if (!volumeEnabled) {
callback?.();
return;
}
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) {
callback?.();
return;
}
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
try {
// "Ready?" â€“ A5 (880Hz), 0.3s
const osc1 = audioContext.createOscillator();
const gain1 = audioContext.createGain();
osc1.type = 'sine';
osc1.frequency.value = 880;
gain1.gain.value = 0.3;
osc1.connect(gain1);
gain1.connect(audioContext.destination);
osc1.start(audioContext.currentTime);
osc1.stop(audioContext.currentTime + 0.3);

// "Go!" â€“ A4 (440Hz), start at 0.4s, duration 0.4s
const osc2 = audioContext.createOscillator();
const gain2 = audioContext.createGain();
osc2.type = 'square';
osc2.frequency.value = 440;
gain2.gain.value = 0.4;
osc2.connect(gain2);
gain2.connect(audioContext.destination);
osc2.start(audioContext.currentTime + 0.4);
osc2.stop(audioContext.currentTime + 0.8);

setTimeout(() => callback?.(), 850);
} catch (e) {
console.warn('Failed to play Ready? Go! sound:', e);
callback?.();
}
}

// ===== æ¯10ç§’æç¤ºéŸ³ =====ï¼ˆä¿æŒä¸è®Šï¼‰
function playTenSecondBeep() {
if (!volumeEnabled) return;
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.type = 'sine';
osc.frequency.value = 660;
gain.gain.value = 0.2;
osc.connect(gain);
gain.connect(audioContext.destination);
osc.start();
osc.stop(audioContext.currentTime + 0.15);
}

// ===== æœ€å¾Œ5ç§’å€’æ•¸èªéŸ³/éŸ³æ•ˆ =====ï¼ˆä¿æŒä¸è®Šï¼‰
function playCountdownVoice(num) {
const words = {5: 'Five', 4: 'Four', 3: 'Three', 2: 'Two', 1: 'One'};
const word = words[num];
if (!volumeEnabled) return;
if ('speechSynthesis' in window) {
const utterance = new SpeechSynthesisUtterance(word);
utterance.lang = 'en-US';
utterance.rate = 1.0;
utterance.volume = 0.8;
speechSynthesis.speak(utterance);
return;
}
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
const frequencies = {5: 440, 4: 523, 3: 587, 2: 659, 1: 784};
const freq = frequencies[num] || 440;
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.type = 'sine';
osc.frequency.value = freq;
gain.gain.value = 0.3;
osc.connect(gain);
gain.connect(audioContext.destination);
osc.start();
osc.stop(audioContext.currentTime + 0.3);
}

// ===== é¼“å‹µèªéŸ³ =====
function playEncouragementSound() {
if (!volumeEnabled) return;
const phrases = ["wonderful", "fantastic", "great", "Excellent", "Amazing"];
const phrase = phrases[Math.floor(Math.random() * phrases.length)];
if ('speechSynthesis' in window) {
const utterance = new SpeechSynthesisUtterance(phrase);
utterance.lang = 'en-US';
utterance.rate = 1.0;
utterance.pitch = 1.2;
utterance.volume = 0.9;
speechSynthesis.speak(utterance);
return;
}
if (!audioContext && window.AudioContext) {
audioContext = new (window.AudioContext || window.webkitAudioContext)();
}
if (!audioContext) return;
if (audioContext.state === 'suspended') {
audioContext.resume().catch(e => console.warn('Resume failed:', e));
}
const notes = [523, 659, 784];
let time = audioContext.currentTime;
for (let i = 0; i < notes.length; i++) {
const osc = audioContext.createOscillator();
const gain = audioContext.createGain();
osc.type = 'sine';
osc.frequency.value = notes[i];
gain.gain.value = 0.25;
osc.connect(gain);
gain.connect(audioContext.destination);
osc.start(time + i * 0.1);
osc.stop(time + i * 0.1 + 0.12);
}
}

// ===== è¨ˆæ™‚ç³»çµ± =====
function startTimer() {
if (timer) clearInterval(timer);
timeLeft = 60;
isGameActive = true;
updateTimerUI();
timer = setInterval(() => {
if (!isGameActive || currentTarget === null) {
clearInterval(timer);
timer = null;
return;
}
timeLeft--;
updateTimerUI();
if (timeLeft > 5 && timeLeft % 10 === 0) {
playTenSecondBeep();
}
if (timeLeft >= 1 && timeLeft <= 5) {
playCountdownVoice(timeLeft);
}
if (timeLeft <= 0) {
clearInterval(timer);
timer = null;
isGameActive = false;
if (currentTarget !== null && originalHand.length > 0) {
showFailureScreen();
}
}
}, 1000);
}
function updateTimerUI() {
document.getElementById('timeLeft').textContent = timeLeft;
const fill = document.getElementById('timerFill');
if (fill) {
const percent = Math.max(0, timeLeft / 60 * 100);
fill.style.width = percent + '%';
if (timeLeft <= 18) {
fill.style.background = '#d63031';
} else {
fill.style.background = '#0984e3';
}
}
}

// ===== è¨ˆåˆ†ç³»çµ± =====
function addScore(base, timeBonus = 0, isCombo = false) {
let total = base + timeBonus;
if (isCombo && combo > 1) {
total = Math.floor(total * (1 + (combo - 1) * 0.2));
}
score += total;
document.getElementById('score').textContent = score;
}

// ===== æ ¸å¿ƒé‚è¼¯ï¼šå¡ç‰Œé¸æ“‡ =====
function selectCard(card) {
if (!isGameActive) return;
if (selectedOperator !== null) {
if (card === selectedCard1) {
showMessage('ä¸èƒ½èˆ‡è‡ªå·±é‹ç®—ï¼', 'error');
return;
}
performCalculation(card);
return;
}
if (selectedCard1 === null) {
selectedCard1 = card;
card.classList.add('selected-first');
document.getElementById('operatorMenu').style.display = 'flex';
showMessage('å·²é¸æ“‡ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦', 'info');
} else if (card === selectedCard1) {
clearSelection();
showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
} else {
selectedCard1.classList.remove('selected-first');
selectedCard1 = card;
card.classList.add('selected-first');
showMessage('å·²åˆ‡æ›ç‚ºæ–°çš„ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦', 'info');
}
}
function selectOperator(op) {
if (selectedCard1 === null || !isGameActive) {
showMessage('è«‹å…ˆé¸æ“‡ç¬¬ä¸€å¼µå¡ï¼', 'error');
return;
}
selectedOperator = op;
showMessage('å·²é¸æ“‡ "' + op + '"ï¼Œè«‹é»æ“Šç¬¬äºŒå¼µå¡', 'info');
playCalculationSound(op);
}
function performCalculation(secondCard) {
const val1 = parseFloat(selectedCard1.dataset.value);
const val2 = parseFloat(secondCard.dataset.value);
let result;
switch(selectedOperator) {
case '+':
result = val1 + val2;
break;
case 'âˆ’':
if (Math.abs(val1 - val2) < 1e-9) {
showMessage('âŒ ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›ï¼', 'error');
clearSelection();
return;
}
result = val1 - val2;
break;
case 'Ã—':
result = val1 * val2;
break;
case 'Ã·':
if (Math.abs(val2) < 1e-9) {
showMessage('âŒ ä¸èƒ½é™¤ä»¥é›¶ï¼', 'error');
clearSelection();
return;
}
if (Math.abs(val1 % val2) > 1e-9) {
showMessage('âŒ é™¤æ³•çµæœå¿…é ˆç‚ºæ•´æ•¸ï¼', 'error');
clearSelection();
return;
}
result = val1 / val2;
break;
default:
clearSelection();
return;
}
if (result < 0) {
showMessage('âŒ çµæœä¸èƒ½ç‚ºè² æ•¸ï¼', 'error');
clearSelection();
return;
}
selectedCard1.remove();
secondCard.remove();
const newCard = createCard(result, true);
document.getElementById('handArea').appendChild(newCard);
clearSelection();
currentStep++;
playEncouragementSound();
const remainingCards = document.querySelectorAll('.card');
if (remainingCards.length === 1) {
const finalValue = parseFloat(remainingCards[0].dataset.value);
if (Math.abs(finalValue - currentTarget) < 1e-6) {
const timeBonus = timeLeft * 10;
combo++;
addScore(100, timeBonus, true);
clearInterval(timer);
timer = null;
isGameActive = false;
showSuccessScreen();
} else {
combo = 0;
clearInterval(timer);
timer = null;
isGameActive = false;
showFailureScreen();
}
}
}
function cancelSelection() {
clearSelection();
showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
}
function clearSelection() {
if (selectedCard1) {
selectedCard1.classList.remove('selected-first');
selectedCard1 = null;
}
selectedOperator = null;
document.getElementById('operatorMenu').style.display = 'none';
}
function resetHand() {
if (!isGameActive) return;
clearSelection();
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
currentStep = 0;
startTimer();
showMessage('å·²é‡è¨­æ‰‹ç‰Œ', 'info');
}
function showHint() {
const cards = Array.from(document.querySelectorAll('.card')).map(card =>
parseFloat(card.dataset.value)
);
if (cards.length === 0) return 'è«‹å…ˆé¸æ“‡å¡ç‰Œ';
const sortedCards = [...cards].sort((a, b) => a - b);
const target = currentTarget;
switch(currentStep + 1) {
case 1:
if (sortedCards.includes(1)) {
return 'æœ‰1çš„è©±ï¼Œå…ˆç”¨1å’Œå…¶ä»–æ•¸å­—ç›¸åŠ ';
}
if (sortedCards.some(x => x <= 7)) {
return 'å…ˆåˆä½µå…©å€‹å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰';
}
if (sortedCards.some(x => x >= 10)) {
return 'æœ‰å¤§æ•¸å­—ï¼ˆâ‰¥10ï¼‰æ™‚ï¼Œè€ƒæ…®ç”¨æ¸›æ³•æˆ–é™¤æ³•';
}
return 'å°‹æ‰¾å¯ä»¥æ•´é™¤çš„æ•¸å­—å°';
case 2:
if (sortedCards.some(x => x > 10)) {
return 'å¤§æ•¸å­—ï¼ˆ>10ï¼‰å»ºè­°ç”¨æ¸›æ³•æˆ–é™¤æ³•';
}
if (sortedCards.some(x => x === 1)) {
return '1å¯ä»¥ç”¨ä¾†å¾®èª¿çµæœ';
}
if (sortedCards.some(x => x <= 7)) {
return 'å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰é©åˆç”¨ä¾†èª¿æ•´çµæœ';
}
if (target && sortedCards.some(x => target % x === 0)) {
return 'å°‹æ‰¾ç›®æ¨™å€¼çš„å› æ•¸';
}
return 'å˜—è©¦è£½é€ ç›®æ¨™å€¼çš„å› æ•¸';
case 3:
if (target && sortedCards.length >= 2) {
const sum = sortedCards.reduce((a, b) => a + b, 0);
if (sum === target) {
return 'æ‰€æœ‰æ•¸å­—ç›¸åŠ ç­‰æ–¼ç›®æ¨™ï¼';
}
if (Math.abs(sum - target) <= 2) {
return 'ç¸½å’Œæ¥è¿‘ç›®æ¨™ï¼Œèª¿æ•´é‹ç®—ç¬¦';
}
if (sortedCards.some(x => x <= 7 && (target - x >= 0))) {
return 'ç”¨å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰ä¾†å¾®èª¿çµæœ';
}
if (sortedCards.some(x => x * 2 === target || x * 3 === target)) {
return 'æœ‰æ•¸å­—æ˜¯ç›®æ¨™å€¼çš„ä¸€åŠæˆ–ä¸‰åˆ†ä¹‹ä¸€';
}
}
return 'æª¢æŸ¥æ˜¯å¦èƒ½ç”¨ä¹˜æ³•å¿«é€Ÿæ¥è¿‘ç›®æ¨™';
case 4:
if (sortedCards.length === 2) {
const [a, b] = sortedCards;
const target = currentTarget;
if (target) {
if (a + b === target) return 'ç”¨åŠ æ³•ï¼';
if (Math.abs(a - b) === target) return 'ç”¨æ¸›æ³•ï¼';
if (a * b === target) return 'ç”¨ä¹˜æ³•ï¼';
if (b !== 0 && a % b === 0 && a / b === target) return 'ç”¨é™¤æ³•ï¼';
if (a !== 0 && b % a === 0 && b / a === target) return 'ç”¨é™¤æ³•ï¼ˆäº¤æ›é †åºï¼‰ï¼';
}
return 'åªå‰©å…©å¼µå¡ï¼Œè©¦è©¦æ‰€æœ‰é‹ç®—ç¬¦ï¼';
}
return 'é€™æ˜¯æœ€å¾Œä¸€æ­¥ï¼Œä»”ç´°è¨ˆç®—ï¼';
default:
return 'æ­£å¸¸é€²è¡ŒéŠæˆ²';
}
}
function showMessage(text, type) {
const msg = document.getElementById('message');
msg.textContent = text;
msg.className = 'message ' + type;
}

// ===== æˆåŠŸ/å¤±æ•—è™•ç† =====
const SUCCESS_MESSAGES = [
"ä½ çœŸæ˜¯æ•¸å­¸å¤©æ‰ï¼",
"å¤ªç¥äº†ï¼å®Œå…¨æ­£ç¢ºï¼",
"å®Œç¾è¨ˆç®—ï¼ç„¡å¯æŒ‘å‰”ï¼",
"æ•¸å­¸å°é”äººå°±æ˜¯ä½ ï¼",
"ç²¾æº–ç„¡èª¤ï¼å¤ªå²å®³äº†ï¼",
"è¨ˆç®—è¶…ç´šæº–ç¢ºï¼",
"ä½ è®“æ•¸å­¸è®Šå¾—è¶…ç°¡å–®ï¼",
"å®Œç¾è§£é¡Œï¼çœŸæ£’ï¼"
];
const FAILURE_MESSAGES = [
"æ²’é—œä¿‚ï¼Œå†è©¦ä¸€æ¬¡ï¼",
"å·®ä¸€é»å°±æˆåŠŸäº†ï¼",
"ç¹¼çºŒåŠ æ²¹ï¼Œä½ å¾ˆæ£’ï¼",
"ä¸è¦æ”¾æ£„ï¼Œä¸‹æ¬¡ä¸€å®šè¡Œï¼",
"å­¸ç¿’å°±æ˜¯ä¸æ–·å˜—è©¦ï¼",
"ä½ å·²ç¶“å¾ˆæ¥è¿‘äº†ï¼",
"æ¯å€‹éŒ¯èª¤éƒ½æ˜¯é€²æ­¥çš„æ©Ÿæœƒï¼",
"ç›¸ä¿¡è‡ªå·±ï¼Œä½ å¯ä»¥çš„ï¼"
];
function showSuccessScreen() {
playSuccessSound();
const usedTime = 60 - timeLeft;
document.getElementById('successTimeMessage').textContent = `ğŸ‰ ä½ èŠ±äº† ${usedTime} ç§’å®Œæˆï¼`;
const randomMessage = SUCCESS_MESSAGES[Math.floor(Math.random() * SUCCESS_MESSAGES.length)];
document.getElementById('successMessage').textContent = randomMessage;
document.getElementById('successModal').style.display = 'flex';
}
function showFailureScreen() {
playFailureSound();
const randomMessage = FAILURE_MESSAGES[Math.floor(Math.random() * FAILURE_MESSAGES.length)];
document.getElementById('failureMessage').textContent = randomMessage;
document.getElementById('failureModal').style.display = 'flex';
}

// ===== é¡Œç›®ç”Ÿæˆæ¨¡å¼ =====
const SOLUTION_PATTERNS = [
{
name: 'target_one',
generate: () => {
const a = Math.floor(Math.random() * 13) + 1;
const ops = [a, a, 1, 1, 1];
return { ops, target: 1 };
}
},
{
name: 'target_two',
generate: () => {
const a = Math.floor(Math.random() * 6) + 2;
const ops = [a, a, a, 1, 1];
return { ops, target: 2 };
}
},
{
name: 'small_target',
generate: () => {
const a = Math.floor(Math.random() * 7) + 1;
const b = Math.floor(Math.random() * 7) + 1;
const c = Math.floor(Math.random() * 7) + 1;
const d = 1;
const e = 1;
const ops = [a, b, c, d, e].sort(() => Math.random() - 0.5);
const target = Math.max(3, Math.min(7, a + b + c - d - e));
return { ops, target };
}
},
{
name: 'big_target',
generate: () => {
const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 8);
const sum = ops.reduce((a, b) => a + b, 0);
const target = Math.max(8, Math.min(13, sum - Math.floor(Math.random() * 5)));
return { ops, target };
}
}
];

// ===== é©—è­‰é¡Œç›® =====
function isValidPuzzle(puzzle) {
if (!puzzle.ops.every(x => x >= 1 && x <= 13)) return false;
if (puzzle.target < 1 || puzzle.target > 13) return false;
const sum = puzzle.ops.reduce((a, b) => a + b, 0);
const minPossible = Math.max(1, puzzle.ops.reduce((a, b) => Math.min(a, b), 13));
if (sum < puzzle.target) return false;
if (minPossible > puzzle.target && puzzle.ops.length > 1) return false;
if (puzzle.ops.every(x => x === 1) && puzzle.target !== 5) return false;
return true;
}

// ===== è§£æ URL åƒæ•¸ =====
function parseUrlPuzzle() {
try {
const urlParams = new URLSearchParams(window.location.search);
const handParam = urlParams.get('hand');
const targetParam = urlParams.get('target');
if (!handParam || !targetParam) return null;
const hand = handParam.split(',').map(str => {
const num = parseInt(str.trim(), 10);
if (isNaN(num) || num < 1 || num > 13) throw new Error('Invalid card value');
return num;
});
if (hand.length !== 5) throw new Error('Must have exactly 5 cards');
const target = parseInt(targetParam.trim(), 10);
if (isNaN(target) || target < 1 || target > 13) throw new Error('Invalid target value');
if (!isValidPuzzle({ ops: hand, target })) throw new Error('Invalid puzzle combination');
return { hand, target };
} catch (e) {
console.warn('URL puzzle parsing failed:', e.message);
return null;
}
}

// ===== ç”Ÿæˆå”¯ä¸€é¡Œç›® =====
function generateUniquePuzzle() {
let attempts = 0;
const maxAttempts = 100;
while (attempts < maxAttempts) {
const isSmallTarget = Math.random() < 0.65;
const targetRange = isSmallTarget ? [1, 7] : [8, 13];
const smallPatterns = ['target_one', 'target_two', 'small_target'];
const bigPatterns = ['big_target'];
const availablePatterns = isSmallTarget ? smallPatterns : bigPatterns;
const patternName = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
const pattern = SOLUTION_PATTERNS.find(p => p.name === patternName);
try {
const puzzle = pattern.generate();
if (puzzle.target >= targetRange[0] && puzzle.target <= targetRange[1]) {
if (isValidPuzzle(puzzle)) {
const signature = getPuzzleSignature(puzzle);
if (!generatedPuzzles.has(signature)) {
generatedPuzzles.add(signature);
return puzzle;
}
}
}
} catch (e) {}
attempts++;
}
const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 7) + 1);
const target = Math.max(1, Math.min(7, ops.reduce((a, b) => a + b, 0) - 3));
return { ops, target };
}
function getPuzzleSignature(puzzle) {
const sortedOps = [...puzzle.ops].sort((a, b) => a - b);
return sortedOps.join(',') + '|' + puzzle.target;
}

// ===== è¼‰å…¥æ–°éŠæˆ² =====
function loadNewGame(useSnapshot = false) {
combo = 0;
currentStep = 0;
let puzzle = null;
if (useSnapshot && currentGameSnapshot) {
puzzle = {
ops: [...currentGameSnapshot.hand],
target: currentGameSnapshot.target
};
} else {
puzzle = generateUniquePuzzle();
}
const { ops: hand, target } = puzzle;
currentTarget = target;
originalHand = [...hand];
currentPuzzle = {
hand: [...hand],
target: target
};
currentGameSnapshot = {
target: currentTarget,
hand: [...originalHand],
score: score,
timeLeft: timeLeft
};
}

// ===== æ–°éŠæˆ²ï¼ˆæ›ä¸€é¡Œï¼‰=====
function newGame() {
if (timer) {
clearInterval(timer);
timer = null;
}
loadNewGame();
playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== åˆ†äº«æŒ‘æˆ° =====
async function shareChallenge() {
if (!currentPuzzle) {
alert('ç„¡æ³•å–å¾—é¡Œç›®è³‡è¨Š');
return;
}
const { hand, target } = currentPuzzle;
const cardsStr = hand.join(',');
const baseUrl = "https://lewiskk0793-netizen.github.io/Math-Royale/";
const urlWithParams = `${baseUrl}?hand=${cardsStr}&target=${target}`;
const shareText = `ã€Math Royale æŒ‘æˆ°ã€‘ç”¨ ${cardsStr} ç®—å‡º ${target}ï¼ä½ èƒ½è§£é–‹å—ï¼ŸğŸ‘‰ ${urlWithParams}`;
try {
await navigator.clipboard.writeText(shareText);
showMessage('âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
} catch (err) {
const textArea = document.createElement('textarea');
textArea.value = shareText;
textArea.style.position = 'fixed';
textArea.style.left = '-9999px';
document.body.appendChild(textArea);
textArea.select();
try {
const success = document.execCommand('copy');
if (success) {
showMessage('âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
} else {
showMessage('è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
}
} catch (e) {
showMessage('è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
}
document.body.removeChild(textArea);
}
setTimeout(() => {
const msg = document.getElementById('message');
if (msg.textContent.includes('å·²è¤‡è£½')) {
msg.textContent = 'ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼';
msg.className = 'message info';
}
}, 3000);
}

// ===== å¾ç©æ³•èªªæ˜é–‹å§‹éŠæˆ²ï¼ˆå„ªå…ˆä½¿ç”¨å¿«ç…§é¡Œç›®ï¼‰=====
function startGameFromInstructions() {
document.getElementById('instructionsModal').style.display = 'none';
  
// å„ªå…ˆä½¿ç”¨å¿«ç…§ä¸­çš„é¡Œç›®ï¼ˆä¾‹å¦‚å¾åˆ†äº«é€£çµè¼‰å…¥ï¼‰
if (currentGameSnapshot && currentGameSnapshot.hand && currentGameSnapshot.target) {
currentTarget = currentGameSnapshot.target;
originalHand = [...currentGameSnapshot.hand];
currentPuzzle = { hand: [...originalHand], target: currentTarget };
} else {
// å¦å‰‡ç”Ÿæˆæ–°é¡Œç›®
loadNewGame();
}

playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== Modal æ§åˆ¶ =====
function closeInstructions() {
alert('è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
}
window.onclick = function(event) {
const modal = document.getElementById('instructionsModal');
if (event.target === modal) {
alert('è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
}
};

// ===== é‡æ–°é–‹å§‹ =====
function restartGame() {
if (timer) {
clearInterval(timer);
timer = null;
}
document.getElementById('successModal').style.display = 'none';
document.getElementById('failureModal').style.display = 'none';
document.getElementById('handArea').innerHTML = '';
document.getElementById('targetCard').textContent = '?';
showMessage('ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼', 'info');
if (currentGameSnapshot) {
currentTarget = currentGameSnapshot.target;
originalHand = [...currentGameSnapshot.hand];
score = currentGameSnapshot.score;
timeLeft = currentGameSnapshot.timeLeft;
document.getElementById('score').textContent = score;
document.getElementById('timeLeft').textContent = timeLeft;
} else {
score = 0;
combo = 0;
currentStep = 0;
timeLeft = 60;
document.getElementById('score').textContent = '0';
document.getElementById('timeLeft').textContent = '60';
}
playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== ç¹¼çºŒæŒ‘æˆ° =====
function continueChallenge() {
if (timer) {
clearInterval(timer);
timer = null;
}
document.getElementById('successModal').style.display = 'none';
document.getElementById('failureModal').style.display = 'none';
currentTarget = null;
originalHand = [];
score = 0;
combo = 0;
currentStep = 0;
isGameActive = false;
timeLeft = 60;
document.getElementById('score').textContent = '0';
document.getElementById('timeLeft').textContent = '60';
document.getElementById('message').textContent = 'ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼';
document.getElementById('message').className = 'message info';
document.getElementById('handArea').innerHTML = '';
document.getElementById('targetCard').textContent = '?';
playReadyGoSound(() => {
loadNewGame();
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== å•Ÿå‹•éŠæˆ² =====
document.addEventListener('DOMContentLoaded', () => {
currentTarget = null;
originalHand = [];
score = 0;
combo = 0;
currentStep = 0;
isGameActive = false;
timeLeft = 60;
timer = null;
currentGameSnapshot = null;
volumeEnabled = true;
audioContext = null;
currentPuzzle = null;
document.getElementById('score').textContent = '0';
document.getElementById('timeLeft').textContent = '60';
document.getElementById('targetCard').textContent = '?';
document.getElementById('handArea').innerHTML = '';
document.getElementById('message').textContent = 'ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼';
document.getElementById('successModal').style.display = 'none';
document.getElementById('failureModal').style.display = 'none';

// æª¢æŸ¥ URL æ˜¯å¦æœ‰é¡Œç›®
const urlPuzzle = parseUrlPuzzle();
if (urlPuzzle) {
// å¾åˆ†äº«é€£çµè¼‰å…¥ â†’ é è¼‰é¡Œç›®ä¸¦é¡¯ç¤º UI
currentTarget = urlPuzzle.target;
originalHand = [...urlPuzzle.hand];
currentPuzzle = { hand: [...originalHand], target: currentTarget };
currentGameSnapshot = {
target: currentTarget,
hand: [...originalHand],
score: 0,
timeLeft: 60
};

// ç«‹å³æ›´æ–° UIï¼ˆä½†ä¸é–‹å§‹è¨ˆæ™‚ï¼‰
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}

// éš±è—ç©æ³•èªªæ˜ï¼Œç›´æ¥é¡¯ç¤ºéŠæˆ²ç•Œé¢
document.getElementById('instructionsModal').style.display = 'none';
} else {
// ç„¡åˆ†äº«åƒæ•¸ â†’ é¡¯ç¤ºç©æ³•èªªæ˜
document.getElementById('instructionsModal').style.display = 'flex';
}
});
</script>
</body>
</html>

