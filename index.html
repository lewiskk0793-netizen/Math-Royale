<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Math Royale</title>
<style>
* {
box-sizing: border-box;
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
background: #f0f5ff;
margin: 0;
padding: 16px 0;
color: #333;
min-height: 100vh;
display: block;
touch-action: manipulation;
}
.container {
width: 95%;
max-width: 800px;
background: white;
padding: 16px;
border-radius: 16px;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
margin: 0 auto;
}
h1 {
text-align: center;
color: #2c3e50;
margin-top: 0;
font-size: 24px;
}
.score-time {
display: flex;
justify-content: space-between;
margin-bottom: 16px;
font-weight: bold;
align-items: center;
font-size: 16px;
}
.timer-bar {
height: 8px;
background: #e0e0e0;
border-radius: 4px;
overflow: hidden;
margin-top: 6px;
}
.timer-fill {
height: 100%;
background: #0984e3;
width: 100%;
transition: width 0.1s linear;
}
.target-row {
display: flex;
justify-content: center;
margin: 16px 0;
}
.target-card {
width: 60px;
height: 80px;
border: 3px solid #d63031;
border-radius: 10px;
display: flex;
align-items: center;
justify-content: center;
font-size: 18px;
font-weight: bold;
background: #ffeaa7;
}
.hand-area {
min-height: 110px;
height: 110px;
max-height: 110px;
margin: 16px 0;
padding: 0 8px;
background: #fafafa;
border-radius: 12px;
display: flex;
flex-wrap: nowrap;
gap: 10px;
justify-content: center;
align-items: center;
overflow-x: hidden;
overflow-y: hidden;
}
.card {
width: calc(16vw - 12px);
min-width: 50px;
max-width: 60px;
flex-shrink: 0;
height: 80px;
border: 3px solid #333;
border-radius: 10px;
display: flex;
align-items: center;
justify-content: center;
font-size: 16px;
font-weight: bold;
background: white;
cursor: pointer;
-webkit-tap-highlight-color: transparent;
transition: all 0.2s;
}
.card.selected-first {
border-color: #0984e3;
transform: scale(1.08);
box-shadow: 0 0 16px rgba(9, 132, 227, 0.6);
}
.operator-menu {
display: none;
justify-content: center;
gap: 14px;
margin: 16px 0;
flex-wrap: wrap;
height: 60px;
}
.op-btn {
width: 50px;
height: 50px;
font-size: 22px;
font-weight: bold;
border: none;
border-radius: 50%;
background: #0984e3;
color: white;
cursor: pointer;
}
.cancel-btn {
padding: 8px 16px;
background: #ff7675;
color: white;
border: none;
border-radius: 8px;
cursor: pointer;
font-weight: bold;
font-size: 14px;
}
.buttons {
display: flex;
gap: 12px;
flex-wrap: wrap;
justify-content: center;
margin: 20px 0;
}
button {
padding: 10px 16px;
font-size: 16px;
border: none;
border-radius: 10px;
cursor: pointer;
background: #0984e3;
color: white;
font-weight: bold;
}
#hintBtn { background: #00b894; }
#nextBtn { background: #fdcb6e; color: #2d3436; }
#resetBtn { background: #a29bfe; }
#volumeBtn { background: #6c5ce7; color: white; }
#volumeBtn.muted { background: #636e72; color: #dfe6e9; }
.message {
margin-top: 16px;
padding: 12px;
border-radius: 10px;
font-weight: bold;
text-align: center;
font-size: 14px;
}
.success { background: #d5f4e6; color: #00a86b; }
.error { background: #ffdddd; color: #d63031; }
.info { background: #e3f2fd; color: #0984e3; }
/* Modal é€šç”¨ */
.modal,
#successModal,
#failureModal,
#instructionsModal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0,0,0,0.6);
overflow: auto;
justify-content: center;
align-items: center;
}
/* æˆåŠŸ/å¤±æ•—å½ˆçª— */
#successModal .modal-content,
#failureModal .modal-content {
display: inline-block;
background: white;
padding: 16px;
border-radius: 12px;
text-align: center;
box-shadow: 0 6px 24px rgba(0,0,0,0.3);
min-width: 280px;
max-width: 90vw;
font-size: 15px;
}
#successModal .modal-content {
background: #d5f4e6;
border: 2px solid #00a86b;
}
#successTimeMessage {
color: #00a86b;
margin-top: 0;
margin-bottom: 8px;
font-size: 18px;
}
#successMessage {
font-size: 14px;
margin: 10px 0;
color: #006400;
}
#failureModal .modal-content {
background: #ffebee;
border: 2px solid #d63031;
}
#failureModal h2 {
color: #d63031;
margin-top: 0;
margin-bottom: 16px;
font-size: 20px;
}
#failureMessage {
font-size: 16px;
margin: 16px 0;
color: #8B0000;
}
/* ===== ç©æ³•èªªæ˜å½ˆçª—æ¨£å¼ï¼ˆç™½è‰²èƒŒæ™¯ï¼‰===== */
#instructionsModal .modal-content {
background: white;
padding: 20px;
border-radius: 12px;
text-align: left;
max-width: 90vw;
max-height: 80vh;
overflow-y: auto;
box-shadow: 0 6px 24px rgba(0,0,0,0.3);
position: relative;
}
#instructionsModal .close {
float: right;
font-size: 24px;
font-weight: bold;
cursor: pointer;
color: #aaa;
}
#instructionsModal .close:hover {
color: #000;
}
#langToggleInModal {
  position: absolute;
  top: 16px;
  right: 16px;
  background: #6c5ce7;
  color: white;
  border: none;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}
.action-buttons {
display: flex;
gap: 10px;
margin-top: 20px;
width: 100%;
}
.action-btn {
flex: 1;
padding: 10px 6px;
border: none;
border-radius: 8px;
font-size: 14px;
font-weight: bold;
cursor: pointer;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 60px;
}
.btn-icon {
font-size: 20px;
margin-bottom: 4px;
display: block;
}
.restart-btn {
background: #6c5ce7;
color: white;
}
.continue-btn {
background: #00a86b;
color: white;
}
#failureModal .continue-btn {
background: #d63031;
}
/* åˆ†äº«æŒ‰éˆ•æ¨£å¼ */
.share-btn {
background: #e17055;
color: white;
border: none;
border-radius: 8px;
padding: 10px;
font-size: 14px;
font-weight: bold;
cursor: pointer;
margin-top: 12px;
display: flex;
align-items: center;
justify-content: center;
gap: 6px;
width: 100%;
}
.share-btn:hover {
background: #d63031;
}
</style>
</head>
<body>
<div class="container">
<h1 id="gameTitle">Math Royale</h1>
<div class="score-time">
<div>ğŸ† <span id="scoreLabel">åˆ†æ•¸</span>: <span id="score">0</span></div>
<div>â±ï¸ <span id="timeLabel">æ™‚é–“</span>: <span id="timeLeft">60</span>s</div>
</div>
<div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
<div class="target-row">
<div class="target-card" id="targetCard">?</div>
</div>
<div class="hand-area" id="handArea"></div>
<div class="operator-menu" id="operatorMenu">
<button class="op-btn" onclick="selectOperator('+')">+</button>
<button class="op-btn" onclick="selectOperator('âˆ’')">âˆ’</button>
<button class="op-btn" onclick="selectOperator('Ã—')">Ã—</button>
<button class="op-btn" onclick="selectOperator('Ã·')">Ã·</button>
<button class="cancel-btn" onclick="cancelSelection()" id="cancelBtn">å–æ¶ˆ</button>
</div>
<div class="buttons">
<button id="hintBtn" onclick="showHint()">æç¤º</button>
<button id="nextBtn" onclick="newGame()">æ›ä¸€é¡Œ</button>
<button id="resetBtn" onclick="resetHand()">é‡ä¾†</button>
<button id="volumeBtn" onclick="toggleVolume()" title="é–‹é—œéŸ³æ•ˆ">ğŸ”Š</button>
</div>
<div id="message" class="message info">ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼</div>
</div>

<!-- ç©æ³•èªªæ˜å½ˆçª— -->
<div id="instructionsModal" class="modal">
<div class="modal-content">
<!-- èªè¨€åˆ‡æ›æŒ‰éˆ•ï¼ˆåƒ…åœ¨ç©æ³•èªªæ˜ä¸­é¡¯ç¤ºï¼‰ -->
<button id="langToggleInModal" onclick="toggleLanguageInModal()">ğŸŒ</button>
<span class="close" onclick="closeInstructions()">&times;</span>
<div class="instructions">
<h2 id="instructionsTitle">ğŸ® ç©æ³•èªªæ˜</h2>
<ul id="instructionsList">
<li><strong>ç›®æ¨™</strong>ï¼šåœ¨ 60 ç§’å…§ç”¨ 5 å¼µç‰Œç®—å‡ºç›®æ¨™å€¼</li>
<li><strong>æ“ä½œ</strong>ï¼š
<br>1. é»æ“Šç¬¬ä¸€å¼µå¡
<br>2. é¸æ“‡é‹ç®—ç¬¦
<br>3. é»æ“Šç¬¬äºŒå¼µå¡ â†’ è‡ªå‹•è¨ˆç®—
</li>
<li><strong>è¦å‰‡</strong>ï¼š
<br>â€¢ ä¸èƒ½ç”¢ç”Ÿè² æ•¸
<br>â€¢ é™¤æ³•å¿…é ˆæ•´é™¤ï¼ˆç„¡é¤˜æ•¸ï¼‰
<br>â€¢ ä¸èƒ½é™¤ä»¥é›¶
<br>â€¢ <strong>ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›</strong>
</li>
<li><strong>è¨ˆåˆ†</strong>ï¼šæˆåŠŸ +100 åˆ† + å‰©é¤˜æ™‚é–“ Ã— 10 åˆ†</li>
</ul>
<p style="text-align:center; margin-top:16px;">
<button onclick="startGameFromInstructions()" id="startGameBtn">é–‹å§‹éŠæˆ²ï¼</button>
</p>
</div>
</div>
</div>

<!-- æˆåŠŸå½ˆå‡ºç•«é¢ -->
<div id="successModal">
<div class="modal-content">
<h2 id="successTimeMessage">ğŸ‰ ä½ èŠ±äº† X ç§’å®Œæˆï¼</h2>
<p id="successMessage"></p>
<button class="share-btn" onclick="shareChallenge()">
<span>ğŸ“¤</span>
<span id="shareBtnText">åˆ†äº«æŒ‘æˆ°</span>
</button>
<div class="action-buttons">
<button class="action-btn restart-btn" onclick="restartGame()">
<span class="btn-icon">ğŸ”„</span>
<span id="restartBtnText">é‡æ–°é–‹å§‹</span>
</button>
<button class="action-btn continue-btn" onclick="continueChallenge()">
<span class="btn-icon">âš¡</span>
<span id="continueBtnText">ç¹¼çºŒæŒ‘æˆ°</span>
</button>
</div>
</div>
</div>

<!-- å¤±æ•—å½ˆå‡ºç•«é¢ -->
<div id="failureModal">
<div class="modal-content">
<h2 id="failureTitle">ğŸ’ª å†è©¦ä¸€æ¬¡ï¼</h2>
<p id="failureMessage"></p>
<button class="share-btn" onclick="shareChallenge()">
<span>ğŸ“¤</span>
<span id="shareBtnText2">åˆ†äº«æŒ‘æˆ°</span>
</button>
<div class="action-buttons">
<button class="action-btn restart-btn" onclick="restartGame()">
<span class="btn-icon">ğŸ”„</span>
<span id="restartBtnText2">é‡æ–°é–‹å§‹</span>
</button>
<button class="action-btn continue-btn" onclick="continueChallenge()">
<span class="btn-icon">âš¡</span>
<span id="continueBtnText2">ç¹¼çºŒæŒ‘æˆ°</span>
</button>
</div>
</div>
</div>

<script>
// ===== èªè¨€è¨­å®š =====
const translations = {
  zh: {
    gameTitle: "Math Royale",
    scoreLabel: "åˆ†æ•¸",
    timeLabel: "æ™‚é–“",
    messageStart: "ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼",
    hintBtn: "æç¤º",
    nextBtn: "æ›ä¸€é¡Œ",
    resetBtn: "é‡ä¾†",
    cancelBtn: "å–æ¶ˆ",
    instructionsTitle: "ğŸ® ç©æ³•èªªæ˜",
    instructions: [
      "<strong>ç›®æ¨™</strong>ï¼šåœ¨ 60 ç§’å…§ç”¨ 5 å¼µç‰Œç®—å‡ºç›®æ¨™å€¼",
      "<strong>æ“ä½œ</strong>ï¼š<br>1. é»æ“Šç¬¬ä¸€å¼µå¡<br>2. é¸æ“‡é‹ç®—ç¬¦<br>3. é»æ“Šç¬¬äºŒå¼µå¡ â†’ è‡ªå‹•è¨ˆç®—",
      "<strong>è¦å‰‡</strong>ï¼š<br>â€¢ ä¸èƒ½ç”¢ç”Ÿè² æ•¸<br>â€¢ é™¤æ³•å¿…é ˆæ•´é™¤ï¼ˆç„¡é¤˜æ•¸ï¼‰<br>â€¢ ä¸èƒ½é™¤ä»¥é›¶<br>â€¢ <strong>ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›</strong>",
      "<strong>è¨ˆåˆ†</strong>ï¼šæˆåŠŸ +100 åˆ† + å‰©é¤˜æ™‚é–“ Ã— 10 åˆ†"
    ],
    startGameBtn: "é–‹å§‹éŠæˆ²ï¼",
    successTimeMessage: (time) => `ğŸ‰ ä½ èŠ±äº† ${time} ç§’å®Œæˆï¼`,
    successMessages: [
      "ä½ çœŸæ˜¯æ•¸å­¸å¤©æ‰ï¼",
      "å¤ªç¥äº†ï¼å®Œå…¨æ­£ç¢ºï¼",
      "å®Œç¾è¨ˆç®—ï¼ç„¡å¯æŒ‘å‰”ï¼",
      "æ•¸å­¸å°é”äººå°±æ˜¯ä½ ï¼",
      "ç²¾æº–ç„¡èª¤ï¼å¤ªå²å®³äº†ï¼",
      "è¨ˆç®—è¶…ç´šæº–ç¢ºï¼",
      "ä½ è®“æ•¸å­¸è®Šå¾—è¶…ç°¡å–®ï¼",
      "å®Œç¾è§£é¡Œï¼çœŸæ£’ï¼"
    ],
    failureTitle: "ğŸ’ª å†è©¦ä¸€æ¬¡ï¼",
    failureMessages: [
      "æ²’é—œä¿‚ï¼Œå†è©¦ä¸€æ¬¡ï¼",
      "å·®ä¸€é»å°±æˆåŠŸäº†ï¼",
      "ç¹¼çºŒåŠ æ²¹ï¼Œä½ å¾ˆæ£’ï¼",
      "ä¸è¦æ”¾æ£„ï¼Œä¸‹æ¬¡ä¸€å®šè¡Œï¼",
      "å­¸ç¿’å°±æ˜¯ä¸æ–·å˜—è©¦ï¼",
      "ä½ å·²ç¶“å¾ˆæ¥è¿‘äº†ï¼",
      "æ¯å€‹éŒ¯èª¤éƒ½æ˜¯é€²æ­¥çš„æ©Ÿæœƒï¼",
      "ç›¸ä¿¡è‡ªå·±ï¼Œä½ å¯ä»¥çš„ï¼"
    ],
    shareBtnText: "åˆ†äº«æŒ‘æˆ°",
    restartBtnText: "é‡æ–°é–‹å§‹",
    continueBtnText: "ç¹¼çºŒæŒ‘æˆ°",
    volumeBtnTitle: "é–‹é—œéŸ³æ•ˆ"
  },
  en: {
    gameTitle: "Math Royale",
    scoreLabel: "Score",
    timeLabel: "Time",
    messageStart: "ğŸ¯ Click the first card!",
    hintBtn: "Hint",
    nextBtn: "Next",
    resetBtn: "Reset",
    cancelBtn: "Cancel",
    instructionsTitle: "ğŸ® How to Play",
    instructions: [
      "<strong>Goal</strong>: Use 5 cards to reach the target value within 60 seconds",
      "<strong>How to play</strong>:<br>1. Click the first card<br>2. Choose an operator<br>3. Click the second card â†’ auto-calculate",
      "<strong>Rules</strong>:<br>â€¢ No negative results<br>â€¢ Division must be exact (no remainder)<br>â€¢ Cannot divide by zero<br>â€¢ <strong>Cannot subtract two identical cards</strong>",
      "<strong>Scoring</strong>: Success +100 points + remaining time Ã— 10 points"
    ],
    startGameBtn: "Start Game!",
    successTimeMessage: (time) => `ğŸ‰ You completed it in ${time} seconds!`,
    successMessages: [
      "You're a math genius!",
      "Amazing! Perfectly correct!",
      "Flawless calculation!",
      "You're the Math Master!",
      "Precise and accurate!",
      "Superb calculation!",
      "You made math look easy!",
      "Perfect solution! Well done!"
    ],
    failureTitle: "ğŸ’ª Try again!",
    failureMessages: [
      "Don't worry, try again!",
      "So close to success!",
      "Keep going, you're great!",
      "Never give up, you'll make it next time!",
      "Learning is all about trying!",
      "You're almost there!",
      "Every mistake is a step forward!",
      "Believe in yourself, you can do it!"
    ],
    shareBtnText: "Share Challenge",
    restartBtnText: "Restart",
    continueBtnText: "Continue",
    volumeBtnTitle: "Toggle Sound"
  }
};

let currentLang = 'zh'; // é è¨­ä¸­æ–‡

// ===== èªè¨€åˆ‡æ›ï¼ˆåƒ…åœ¨ç©æ³•èªªæ˜ä¸­ï¼‰=====
function toggleLanguageInModal() {
  currentLang = currentLang === 'zh' ? 'en' : 'zh';
  updateLanguage();
  // æ›´æ–° URL åƒæ•¸
  const url = new URL(window.location);
  if (currentLang === 'en') {
    url.searchParams.set('lang', 'en');
  } else {
    url.searchParams.delete('lang');
  }
  window.history.replaceState({}, '', url);
}

// ===== æ›´æ–°æ‰€æœ‰æ–‡å­— =====
function updateLanguage() {
  const t = translations[currentLang];
  
  // é é¢æ¨™é¡Œ
  document.getElementById('gameTitle').textContent = t.gameTitle;
  
  // è¨ˆåˆ†å€
  document.getElementById('scoreLabel').textContent = t.scoreLabel;
  document.getElementById('timeLabel').textContent = t.timeLabel;
  
  // æŒ‰éˆ•
  document.getElementById('hintBtn').textContent = t.hintBtn;
  document.getElementById('nextBtn').textContent = t.nextBtn;
  document.getElementById('resetBtn').textContent = t.resetBtn;
  document.getElementById('cancelBtn').textContent = t.cancelBtn;
  document.getElementById('volumeBtn').title = t.volumeBtnTitle;
  
  // ç©æ³•èªªæ˜
  document.getElementById('instructionsTitle').textContent = t.instructionsTitle;
  const instructionsList = document.getElementById('instructionsList');
  instructionsList.innerHTML = '';
  t.instructions.forEach(item => {
    const li = document.createElement('li');
    li.innerHTML = item;
    instructionsList.appendChild(li);
  });
  document.getElementById('startGameBtn').textContent = t.startGameBtn;
  
  // æˆåŠŸ/å¤±æ•—å½ˆçª—
  document.getElementById('shareBtnText').textContent = t.shareBtnText;
  document.getElementById('shareBtnText2').textContent = t.shareBtnText;
  document.getElementById('restartBtnText').textContent = t.restartBtnText;
  document.getElementById('restartBtnText2').textContent = t.restartBtnText;
  document.getElementById('continueBtnText').textContent = t.continueBtnText;
  document.getElementById('continueBtnText2').textContent = t.continueBtnText;
  document.getElementById('failureTitle').textContent = t.failureTitle;
  
  // åˆå§‹è¨Šæ¯
  if (!isGameActive) {
    document.getElementById('message').textContent = t.messageStart;
    document.getElementById('message').className = 'message info';
  }
}

// ===== è§£æ URL èªè¨€åƒæ•¸ =====
function parseUrlLanguage() {
  const urlParams = new URLSearchParams(window.location.search);
  const lang = urlParams.get('lang');
  if (lang === 'en') {
    return 'en';
  }
  return 'zh';
}

// ===== å…¨åŸŸç‹€æ…‹ =====
const VALUE_TO_RANK = {1:'A',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K'};
const SUITS = ['â™ ','â™¥','â™¦','â™£'];
let currentTarget = null;
let originalHand = [];
let selectedCard1 = null;
let selectedOperator = null;
let score = 0;
let combo = 0;
let timeLeft = 60;
let timer = null;
let isGameActive = false;
let currentStep = 0;
let currentGameSnapshot = null;
let lastUsedPattern = -1;
let generatedPuzzles = new Set();
let volumeEnabled = true;
let currentPuzzle = null;

// ===== å·¥å…·å‡½æ•¸ =====
function getRandomSuit() {
return SUITS[Math.floor(Math.random() * SUITS.length)];
}
function valueToDisplay(value) {
if (value >= 1 && value <= 13) {
return VALUE_TO_RANK[value] + getRandomSuit();
}
return String(Math.round(value * 100) / 100);
}
function createCard(value, isNew = false) {
const card = document.createElement('div');
card.className = 'card';
card.textContent = valueToDisplay(value);
card.dataset.value = value;
card.onclick = (e) => {
e.stopPropagation();
selectCard(card);
};
return card;
}

// ===== éŸ³é‡æ§åˆ¶ =====
function toggleVolume() {
volumeEnabled = !volumeEnabled;
const volumeBtn = document.getElementById('volumeBtn');
if (volumeEnabled) {
volumeBtn.textContent = 'ğŸ”Š';
volumeBtn.classList.remove('muted');
} else {
volumeBtn.textContent = 'ğŸ”‡';
volumeBtn.classList.add('muted');
}
}

// ===== è¨ˆç®—éŸ³æ•ˆï¼ˆé»æ“Šé‹ç®—ç¬¦æ™‚ï¼‰=====
function playCalculationSound(operation) {
if (!volumeEnabled) return;
if (!window.AudioContext && !window.webkitAudioContext) return;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
let time = 0;
switch(operation) {
case '+':
{
const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
o1.frequency.value = 523; g1.gain.value = 0.3;
o1.connect(g1); g1.connect(ctx.destination);
o1.start(time); o1.stop(time + 0.2);
const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
o2.frequency.value = 587; g2.gain.value = 0.3;
o2.connect(g2); g2.connect(ctx.destination);
o2.start(time + 0.2); o2.stop(time + 0.4);
setTimeout(() => ctx.close(), 450);
break;
}
case 'âˆ’':
{
const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
o1.frequency.value = 587; g1.gain.value = 0.3;
o1.connect(g1); g1.connect(ctx.destination);
o1.start(time); o1.stop(time + 0.2);
const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
o2.frequency.value = 523; g2.gain.value = 0.3;
o2.connect(g2); g2.connect(ctx.destination);
o2.start(time + 0.2); o2.stop(time + 0.4);
setTimeout(() => ctx.close(), 450);
break;
}
case 'Ã—':
{
const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
o1.frequency.value = 523; g1.gain.value = 0.3;
o1.connect(g1); g1.connect(ctx.destination);
o1.start(time); o1.stop(time + 0.2);
const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
o2.frequency.value = 659; g2.gain.value = 0.3;
o2.connect(g2); g2.connect(ctx.destination);
o2.start(time); o2.stop(time + 0.2);
const o3 = ctx.createOscillator(); const g3 = ctx.createGain();
o3.frequency.value = 784; g3.gain.value = 0.3;
o3.connect(g3); g3.connect(ctx.destination);
o3.start(time + 0.1); o3.stop(time + 0.3);
setTimeout(() => ctx.close(), 350);
break;
}
case 'Ã·':
{
const o1 = ctx.createOscillator(); const g1 = ctx.createGain();
o1.frequency.value = 784; g1.gain.value = 0.3;
o1.connect(g1); g1.connect(ctx.destination);
o1.start(time); o1.stop(time + 0.15);
const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
o2.frequency.value = 1046; g2.gain.value = 0.3;
o2.connect(g2); g2.connect(ctx.destination);
o2.start(time + 0.15); o2.stop(time + 0.3);
setTimeout(() => ctx.close(), 350);
break;
}
}
}

// ===== æˆåŠŸ/å¤±æ•—éŸ³æ•ˆ =====
function playSuccessSound() {
if (!volumeEnabled) return;
if (!window.AudioContext && !window.webkitAudioContext) return;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
const notes = [523, 659, 784, 1046];
const durations = [0.15, 0.15, 0.15, 0.2];
let time = 0;
notes.forEach((freq, i) => {
const osc = ctx.createOscillator();
const gain = ctx.createGain();
osc.frequency.value = freq;
gain.gain.value = 0.3;
osc.connect(gain);
gain.connect(ctx.destination);
osc.start(time);
osc.stop(time + durations[i]);
time += durations[i] + (i === 2 ? 0.15 : 0);
});
setTimeout(() => ctx.close(), 650);
}
function playFailureSound() {
if (!volumeEnabled) return;
if (!window.AudioContext && !window.webkitAudioContext) return;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
const notes = [523, 440, 392];
const times = [0, 0.2, 0.4];
const durations = [0.2, 0.2, 0.25];
notes.forEach((freq, i) => {
const osc = ctx.createOscillator();
const gain = ctx.createGain();
osc.frequency.value = freq;
gain.gain.value = 0.3;
osc.connect(gain);
gain.connect(ctx.destination);
osc.start(times[i]);
osc.stop(times[i] + durations[i]);
});
setTimeout(() => ctx.close(), 700);
}

// ===== âœ… Ready? Go! éŸ³æ•ˆï¼ˆå·²å–æ¶ˆæ‰€æœ‰éŸ³æ•ˆï¼‰=====
function playReadyGoSound(callback) {
  // å·²æ ¹æ“šéœ€æ±‚å–æ¶ˆæ‰€æœ‰ Ready? Go! éŸ³æ•ˆ
  if (callback) {
    setTimeout(callback, 100); // å¾®å°å»¶é²ä»¥ä¿æŒæµç¨‹ä¸€è‡´æ€§
  }
}

// ===== æ¯10ç§’æç¤ºéŸ³ =====
function playTenSecondBeep() {
if (!volumeEnabled) return;
if (!window.AudioContext && !window.webkitAudioContext) return;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
const osc = ctx.createOscillator();
const gain = ctx.createGain();
osc.type = 'sine';
osc.frequency.value = 660;
gain.gain.value = 0.2;
osc.connect(gain);
gain.connect(ctx.destination);
osc.start(0);
osc.stop(0.15);
setTimeout(() => ctx.close(), 200);
}

// ===== å€’æ•¸5ç§’éŸ³æ•ˆ =====
function playCountdownVoice(num) {
  // å„ªå…ˆä½¿ç”¨èªéŸ³åˆæˆ
  if ('speechSynthesis' in window) {
    const words = {5: 'Five', 4: 'Four', 3: 'Three', 2: 'Two', 1: 'One'};
    const word = words[num];
    if (word) {
      const utterance = new SpeechSynthesisUtterance(word);
      utterance.lang = 'en-US';
      utterance.rate = 1.0;
      utterance.volume = 0.8;
      speechSynthesis.speak(utterance);
      return;
    }
  }

  // Fallback to beep (only if volume is enabled)
  if (!volumeEnabled) return;
  if (!window.AudioContext && !window.webkitAudioContext) return;

  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioContext();

  const frequencies = {5: 440, 4: 523, 3: 587, 2: 659, 1: 784};
  const freq = frequencies[num] || 440;

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.value = freq;
  gain.gain.value = 0.3;
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start(0);
  osc.stop(0.3);

  // Auto-close after delay
  setTimeout(() => {
    ctx.close().catch(() => {});
  }, 350);
}

// ===== é¼“å‹µèªéŸ³ï¼ˆè¨ˆç®—æˆåŠŸå¾Œï¼‰=====
function playEncouragementSound() {
if (!volumeEnabled) return;
const phrases = ["wonderful", "fantastic", "great", "Excellent", "Amazing"];
const phrase = phrases[Math.floor(Math.random() * phrases.length)];
if ('speechSynthesis' in window) {
const utterance = new SpeechSynthesisUtterance(phrase);
utterance.lang = 'en-US';
utterance.rate = 1.0;
utterance.pitch = 1.2;
utterance.volume = 0.9;
speechSynthesis.speak(utterance);
return;
}
// Fallback to tone sequence
if (!window.AudioContext && !window.webkitAudioContext) return;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
const notes = [523, 659, 784];
let time = 0;
for (let i = 0; i < notes.length; i++) {
const osc = ctx.createOscillator();
const gain = ctx.createGain();
osc.frequency.value = notes[i];
gain.gain.value = 0.25;
osc.connect(gain);
gain.connect(ctx.destination);
osc.start(time + i * 0.1);
osc.stop(time + i * 0.1 + 0.12);
}
setTimeout(() => ctx.close(), 350);
}

// ===== è¨ˆæ™‚ç³»çµ± =====
function startTimer() {
if (timer) clearInterval(timer);
timeLeft = 60;
isGameActive = true;
updateTimerUI();
timer = setInterval(() => {
if (!isGameActive || currentTarget === null) {
clearInterval(timer);
timer = null;
return;
}
timeLeft--;
updateTimerUI();
if (timeLeft > 5 && timeLeft % 10 === 0) {
playTenSecondBeep();
}
if (timeLeft >= 1 && timeLeft <= 5) {
playCountdownVoice(timeLeft);
}
if (timeLeft <= 0) {
clearInterval(timer);
timer = null;
isGameActive = false;
if (currentTarget !== null && originalHand.length > 0) {
showFailureScreen();
}
}
}, 1000);
}
function updateTimerUI() {
document.getElementById('timeLeft').textContent = timeLeft;
const fill = document.getElementById('timerFill');
if (fill) {
const percent = Math.max(0, timeLeft / 60 * 100);
fill.style.width = percent + '%';
if (timeLeft <= 18) {
fill.style.background = '#d63031';
} else {
fill.style.background = '#0984e3';
}
}
}

// ===== è¨ˆåˆ†ç³»çµ± =====
function addScore(base, timeBonus = 0, isCombo = false) {
let total = base + timeBonus;
if (isCombo && combo > 1) {
total = Math.floor(total * (1 + (combo - 1) * 0.2));
}
score += total;
document.getElementById('score').textContent = score;
}

// ===== æ ¸å¿ƒé‚è¼¯ï¼šå¡ç‰Œé¸æ“‡ =====
function selectCard(card) {
if (!isGameActive) return;
if (selectedOperator !== null) {
if (card === selectedCard1) {
showMessage('ä¸èƒ½èˆ‡è‡ªå·±é‹ç®—ï¼', 'error');
return;
}
performCalculation(card);
return;
}
if (selectedCard1 === null) {
selectedCard1 = card;
card.classList.add('selected-first');
document.getElementById('operatorMenu').style.display = 'flex';
showMessage('å·²é¸æ“‡ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦', 'info');
} else if (card === selectedCard1) {
clearSelection();
showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
} else {
selectedCard1.classList.remove('selected-first');
selectedCard1 = card;
card.classList.add('selected-first');
showMessage('å·²åˆ‡æ›ç‚ºæ–°çš„ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦', 'info');
}
}
function selectOperator(op) {
if (selectedCard1 === null || !isGameActive) {
showMessage('è«‹å…ˆé¸æ“‡ç¬¬ä¸€å¼µå¡ï¼', 'error');
return;
}
selectedOperator = op;
showMessage('å·²é¸æ“‡ "' + op + '"ï¼Œè«‹é»æ“Šç¬¬äºŒå¼µå¡', 'info');
playCalculationSound(op);
}
function performCalculation(secondCard) {
const val1 = parseFloat(selectedCard1.dataset.value);
const val2 = parseFloat(secondCard.dataset.value);
let result;
switch(selectedOperator) {
case '+':
result = val1 + val2;
break;
case 'âˆ’':
if (Math.abs(val1 - val2) < 1e-9) {
showMessage('âŒ ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›ï¼', 'error');
clearSelection();
return;
}
result = val1 - val2;
break;
case 'Ã—':
result = val1 * val2;
break;
case 'Ã·':
if (Math.abs(val2) < 1e-9) {
showMessage('âŒ ä¸èƒ½é™¤ä»¥é›¶ï¼', 'error');
clearSelection();
return;
}
if (Math.abs(val1 % val2) > 1e-9) {
showMessage('âŒ é™¤æ³•çµæœå¿…é ˆç‚ºæ•´æ•¸ï¼', 'error');
clearSelection();
return;
}
result = val1 / val2;
break;
default:
clearSelection();
return;
}
if (result < 0) {
showMessage('âŒ çµæœä¸èƒ½ç‚ºè² æ•¸ï¼', 'error');
clearSelection();
return;
}
selectedCard1.remove();
secondCard.remove();
const newCard = createCard(result, true);
document.getElementById('handArea').appendChild(newCard);
clearSelection();
currentStep++;
playEncouragementSound();
const remainingCards = document.querySelectorAll('.card');
if (remainingCards.length === 1) {
const finalValue = parseFloat(remainingCards[0].dataset.value);
if (Math.abs(finalValue - currentTarget) < 1e-6) {
const timeBonus = timeLeft * 10;
combo++;
addScore(100, timeBonus, true);
clearInterval(timer);
timer = null;
isGameActive = false;
showSuccessScreen();
} else {
combo = 0;
clearInterval(timer);
timer = null;
isGameActive = false;
showFailureScreen();
}
}
}
function cancelSelection() {
clearSelection();
showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
}
function clearSelection() {
if (selectedCard1) {
selectedCard1.classList.remove('selected-first');
selectedCard1 = null;
}
selectedOperator = null;
document.getElementById('operatorMenu').style.display = 'none';
}
function resetHand() {
if (!isGameActive) return;
clearSelection();
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
currentStep = 0;
startTimer();
showMessage('å·²é‡è¨­æ‰‹ç‰Œ', 'info');
}

// ===== âœ… ä¿®æ­£ï¼šå¤šèªè¨€æç¤º =====
function showHint() {
  const cards = Array.from(document.querySelectorAll('.card')).map(card =>
    parseFloat(card.dataset.value)
  );
  if (cards.length === 0) {
    return currentLang === 'en' ? 'Please select a card first' : 'è«‹å…ˆé¸æ“‡å¡ç‰Œ';
  }
  const sortedCards = [...cards].sort((a, b) => a - b);
  const target = currentTarget;

  // å¤šèªè¨€æç¤º
  const hints = {
    zh: {
      noCard: "è«‹å…ˆé¸æ“‡å¡ç‰Œ",
      step1: {
        hasOne: "æœ‰1çš„è©±ï¼Œå…ˆç”¨1å’Œå…¶ä»–æ•¸å­—ç›¸åŠ ",
        smallNumbers: "å…ˆåˆä½µå…©å€‹å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰",
        bigNumbers: "æœ‰å¤§æ•¸å­—ï¼ˆâ‰¥10ï¼‰æ™‚ï¼Œè€ƒæ…®ç”¨æ¸›æ³•æˆ–é™¤æ³•",
        default: "å°‹æ‰¾å¯ä»¥æ•´é™¤çš„æ•¸å­—å°"
      },
      step2: {
        bigNumbers: "å¤§æ•¸å­—ï¼ˆ>10ï¼‰å»ºè­°ç”¨æ¸›æ³•æˆ–é™¤æ³•",
        hasOne: "1å¯ä»¥ç”¨ä¾†å¾®èª¿çµæœ",
        smallNumbers: "å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰é©åˆç”¨ä¾†èª¿æ•´çµæœ",
        factor: "å°‹æ‰¾ç›®æ¨™å€¼çš„å› æ•¸",
        default: "å˜—è©¦è£½é€ ç›®æ¨™å€¼çš„å› æ•¸"
      },
      step3: {
        sumEquals: "æ‰€æœ‰æ•¸å­—ç›¸åŠ ç­‰æ–¼ç›®æ¨™ï¼",
        sumClose: "ç¸½å’Œæ¥è¿‘ç›®æ¨™ï¼Œèª¿æ•´é‹ç®—ç¬¦",
        adjustWithSmall: "ç”¨å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰ä¾†å¾®èª¿çµæœ",
        halfOrThird: "æœ‰æ•¸å­—æ˜¯ç›®æ¨™å€¼çš„ä¸€åŠæˆ–ä¸‰åˆ†ä¹‹ä¸€",
        default: "æª¢æŸ¥æ˜¯å¦èƒ½ç”¨ä¹˜æ³•å¿«é€Ÿæ¥è¿‘ç›®æ¨™"
      },
      step4: {
        add: "ç”¨åŠ æ³•ï¼",
        subtract: "ç”¨æ¸›æ³•ï¼",
        multiply: "ç”¨ä¹˜æ³•ï¼",
        divide: "ç”¨é™¤æ³•ï¼",
        divideSwap: "ç”¨é™¤æ³•ï¼ˆäº¤æ›é †åºï¼‰ï¼",
        default: "åªå‰©å…©å¼µå¡ï¼Œè©¦è©¦æ‰€æœ‰é‹ç®—ç¬¦ï¼"
      },
      final: "é€™æ˜¯æœ€å¾Œä¸€æ­¥ï¼Œä»”ç´°è¨ˆç®—ï¼",
      normal: "æ­£å¸¸é€²è¡ŒéŠæˆ²"
    },
    en: {
      noCard: "Please select a card first",
      step1: {
        hasOne: "If you have a 1, add it to another number first",
        smallNumbers: "Combine two small numbers (â‰¤7) first",
        bigNumbers: "For large numbers (â‰¥10), consider subtraction or division",
        default: "Look for pairs that can be evenly divided"
      },
      step2: {
        bigNumbers: "For large numbers (>10), prefer subtraction or division",
        hasOne: "Use 1 to fine-tune the result",
        smallNumbers: "Small numbers (â‰¤7) are good for adjustments",
        factor: "Look for factors of the target value",
        default: "Try to create factors of the target"
      },
      step3: {
        sumEquals: "The sum of all cards equals the target!",
        sumClose: "The total is close to the target, adjust operators",
        adjustWithSmall: "Use small numbers (â‰¤7) to fine-tune the result",
        halfOrThird: "You have a number that is half or one-third of the target",
        default: "Check if multiplication can quickly get close to the target"
      },
      step4: {
        add: "Use addition!",
        subtract: "Use subtraction!",
        multiply: "Use multiplication!",
        divide: "Use division!",
        divideSwap: "Use division (swap order)!",
        default: "Only two cards left, try all operators!"
      },
      final: "This is the final step, calculate carefully!",
      normal: "Proceed normally"
    }
  };

  const t = hints[currentLang];

  switch(currentStep + 1) {
    case 1:
      if (sortedCards.includes(1)) {
        return t.step1.hasOne;
      }
      if (sortedCards.some(x => x <= 7)) {
        return t.step1.smallNumbers;
      }
      if (sortedCards.some(x => x >= 10)) {
        return t.step1.bigNumbers;
      }
      return t.step1.default;
    case 2:
      if (sortedCards.some(x => x > 10)) {
        return t.step2.bigNumbers;
      }
      if (sortedCards.some(x => x === 1)) {
        return t.step2.hasOne;
      }
      if (sortedCards.some(x => x <= 7)) {
        return t.step2.smallNumbers;
      }
      if (target && sortedCards.some(x => target % x === 0)) {
        return t.step2.factor;
      }
      return t.step2.default;
    case 3:
      if (target && sortedCards.length >= 2) {
        const sum = sortedCards.reduce((a, b) => a + b, 0);
        if (sum === target) {
          return t.step3.sumEquals;
        }
        if (Math.abs(sum - target) <= 2) {
          return t.step3.sumClose;
        }
        if (sortedCards.some(x => x <= 7 && (target - x >= 0))) {
          return t.step3.adjustWithSmall;
        }
        if (sortedCards.some(x => x * 2 === target || x * 3 === target)) {
          return t.step3.halfOrThird;
        }
      }
      return t.step3.default;
    case 4:
      if (sortedCards.length === 2) {
        const [a, b] = sortedCards;
        const target = currentTarget;
        if (target) {
          if (a + b === target) return t.step4.add;
          if (Math.abs(a - b) === target) return t.step4.subtract;
          if (a * b === target) return t.step4.multiply;
          if (b !== 0 && a % b === 0 && a / b === target) return t.step4.divide;
          if (a !== 0 && b % a === 0 && b / a === target) return t.step4.divideSwap;
        }
        return t.step4.default;
      }
      return t.final;
    default:
      return t.normal;
  }
}

function showMessage(text, type) {
const msg = document.getElementById('message');
msg.textContent = text;
msg.className = 'message ' + type;
}

// ===== æˆåŠŸ/å¤±æ•—è™•ç† =====
function showSuccessScreen() {
playSuccessSound();
const usedTime = 60 - timeLeft;
const t = translations[currentLang];
document.getElementById('successTimeMessage').textContent = t.successTimeMessage(usedTime);
const randomMessage = t.successMessages[Math.floor(Math.random() * t.successMessages.length)];
document.getElementById('successMessage').textContent = randomMessage;
document.getElementById('successModal').style.display = 'flex';
}
function showFailureScreen() {
playFailureSound();
const t = translations[currentLang];
const randomMessage = t.failureMessages[Math.floor(Math.random() * t.failureMessages.length)];
document.getElementById('failureMessage').textContent = randomMessage;
document.getElementById('failureModal').style.display = 'flex';
}

// ===== é¡Œç›®ç”Ÿæˆæ¨¡å¼ =====
const SOLUTION_PATTERNS = [
{
name: 'target_one',
generate: () => {
const a = Math.floor(Math.random() * 13) + 1;
const ops = [a, a, 1, 1, 1];
return { ops, target: 1 };
}
},
{
name: 'target_two',
generate: () => {
const a = Math.floor(Math.random() * 6) + 2;
const ops = [a, a, a, 1, 1];
return { ops, target: 2 };
}
},
{
name: 'small_target',
generate: () => {
const a = Math.floor(Math.random() * 7) + 1;
const b = Math.floor(Math.random() * 7) + 1;
const c = Math.floor(Math.random() * 7) + 1;
const d = 1;
const e = 1;
const ops = [a, b, c, d, e].sort(() => Math.random() - 0.5);
const target = Math.max(3, Math.min(7, a + b + c - d - e));
return { ops, target };
}
},
{
name: 'big_target',
generate: () => {
const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 8);
const sum = ops.reduce((a, b) => a + b, 0);
const target = Math.max(8, Math.min(13, sum - Math.floor(Math.random() * 5)));
return { ops, target };
}
}
];

// ===== é©—è­‰é¡Œç›® =====
function isValidPuzzle(puzzle) {
if (!puzzle.ops.every(x => x >= 1 && x <= 13)) return false;
if (puzzle.target < 1 || puzzle.target > 13) return false;
const sum = puzzle.ops.reduce((a, b) => a + b, 0);
const minPossible = Math.max(1, puzzle.ops.reduce((a, b) => Math.min(a, b), 13));
if (sum < puzzle.target) return false;
if (minPossible > puzzle.target && puzzle.ops.length > 1) return false;
if (puzzle.ops.every(x => x === 1) && puzzle.target !== 5) return false;
return true;
}

// ===== è§£æ URL åƒæ•¸ =====
function parseUrlPuzzle() {
try {
const urlParams = new URLSearchParams(window.location.search);
const handParam = urlParams.get('hand');
const targetParam = urlParams.get('target');
if (!handParam || !targetParam) return null;
const hand = handParam.split(',').map(str => {
const num = parseInt(str.trim(), 10);
if (isNaN(num) || num < 1 || num > 13) throw new Error('Invalid card value');
return num;
});
if (hand.length !== 5) throw new Error('Must have exactly 5 cards');
const target = parseInt(targetParam.trim(), 10);
if (isNaN(target) || target < 1 || target > 13) throw new Error('Invalid target value');
if (!isValidPuzzle({ ops: hand, target })) throw new Error('Invalid puzzle combination');
return { hand, target };
} catch (e) {
console.warn('URL puzzle parsing failed:', e.message);
return null;
}
}

// ===== ç”Ÿæˆå”¯ä¸€é¡Œç›® =====
function generateUniquePuzzle() {
let attempts = 0;
const maxAttempts = 100;
while (attempts < maxAttempts) {
const isSmallTarget = Math.random() < 0.65;
const targetRange = isSmallTarget ? [1, 7] : [8, 13];
const smallPatterns = ['target_one', 'target_two', 'small_target'];
const bigPatterns = ['big_target'];
const availablePatterns = isSmallTarget ? smallPatterns : bigPatterns;
const patternName = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
const pattern = SOLUTION_PATTERNS.find(p => p.name === patternName);
try {
const puzzle = pattern.generate();
if (puzzle.target >= targetRange[0] && puzzle.target <= targetRange[1]) {
if (isValidPuzzle(puzzle)) {
const signature = getPuzzleSignature(puzzle);
if (!generatedPuzzles.has(signature)) {
generatedPuzzles.add(signature);
return puzzle;
}
}
}
} catch (e) {}
attempts++;
}
const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 7) + 1);
const target = Math.max(1, Math.min(7, ops.reduce((a, b) => a + b, 0) - 3));
return { ops, target };
}
function getPuzzleSignature(puzzle) {
const sortedOps = [...puzzle.ops].sort((a, b) => a - b);
return sortedOps.join(',') + '|' + puzzle.target;
}

// ===== è¼‰å…¥æ–°éŠæˆ² =====
function loadNewGame(useSnapshot = false) {
combo = 0;
currentStep = 0;
let puzzle = null;
if (useSnapshot && currentGameSnapshot) {
puzzle = {
ops: [...currentGameSnapshot.hand],
target: currentGameSnapshot.target
};
} else {
puzzle = generateUniquePuzzle();
}
const { ops: hand, target } = puzzle;
currentTarget = target;
originalHand = [...hand];
currentPuzzle = {
hand: [...hand],
target: target
};
currentGameSnapshot = {
target: currentTarget,
hand: [...originalHand],
score: score,
timeLeft: timeLeft
};
}

// ===== æ–°éŠæˆ²ï¼ˆæ›ä¸€é¡Œï¼‰=====
function newGame() {
if (timer) {
clearInterval(timer);
timer = null;
}
loadNewGame();
playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== âœ… ä¿®æ­£ï¼šå‹•æ…‹å–å¾—åŸºç¤ URL =====
async function shareChallenge() {
  if (!currentPuzzle) {
    alert(currentLang === 'en' ? 'Failed to get puzzle info' : 'ç„¡æ³•å–å¾—é¡Œç›®è³‡è¨Š');
    return;
  }
  const { hand, target } = currentPuzzle;
  const cardsStr = hand.join(',');
  
  // å‹•æ…‹å–å¾—ç•¶å‰é é¢çš„åŸºç¤ URLï¼ˆä¸å«æŸ¥è©¢åƒæ•¸ï¼‰
  const baseUrl = "https://lewiskk0793-netizen.github.io/Math-Royale/";
  
  let urlWithParams = `${baseUrl}?hand=${cardsStr}&target=${target}`;
  if (currentLang === 'en') {
    urlWithParams += '&lang=en';
  }
  
  const shareText = currentLang === 'en' 
    ? `ã€Math Royale Challengeã€‘Use ${cardsStr} to make ${target}! Can you solve it? ğŸ‘‰ ${urlWithParams}`
    : `ã€Math Royale æŒ‘æˆ°ã€‘ç”¨ ${cardsStr} ç®—å‡º ${target}ï¼ä½ èƒ½è§£é–‹å—ï¼ŸğŸ‘‰ ${urlWithParams}`;

  try {
    await navigator.clipboard.writeText(shareText);
    const t = translations[currentLang];
    showMessage(t.lang === 'en' ? 'âœ… Copied! Share with friends!' : 'âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
  } catch (err) {
    const textArea = document.createElement('textarea');
    textArea.value = shareText;
    textArea.style.position = 'fixed';
    textArea.style.left = '-9999px';
    document.body.appendChild(textArea);
    textArea.select();
    try {
      const success = document.execCommand('copy');
      if (success) {
        const t = translations[currentLang];
        showMessage(t.lang === 'en' ? 'âœ… Copied! Share with friends!' : 'âœ… å·²è¤‡è£½ï¼è²¼ä¸Šå³å¯é‚€è«‹æœ‹å‹æŒ‘æˆ°', 'success');
      } else {
        showMessage(currentLang === 'en' ? 'Please copy manually:\n' + shareText : 'è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
      }
    } catch (e) {
      showMessage(currentLang === 'en' ? 'Please copy manually:\n' + shareText : 'è«‹æ‰‹å‹•è¤‡è£½ä»¥ä¸‹æ–‡å­—ï¼š\n' + shareText, 'info');
    }
    document.body.removeChild(textArea);
  }
  setTimeout(() => {
    const msg = document.getElementById('message');
    if (msg.textContent.includes('âœ…')) {
      msg.textContent = translations[currentLang].messageStart;
      msg.className = 'message info';
    }
  }, 3000);
}

// ===== å¾ç©æ³•èªªæ˜é–‹å§‹éŠæˆ²ï¼ˆé—œéµï¼šä½¿ç”¨å¿«ç…§é¡Œç›®æˆ–ç”Ÿæˆæ–°é¡Œç›®ï¼‰=====
function startGameFromInstructions() {
document.getElementById('instructionsModal').style.display = 'none';
  
// å„ªå…ˆä½¿ç”¨å¿«ç…§ä¸­çš„é¡Œç›®ï¼ˆä¾‹å¦‚å¾åˆ†äº«é€£çµè¼‰å…¥ï¼‰
if (currentGameSnapshot && currentGameSnapshot.hand && currentGameSnapshot.target) {
currentTarget = currentGameSnapshot.target;
originalHand = [...currentGameSnapshot.hand];
currentPuzzle = { hand: [...originalHand], target: currentTarget };
} else {
// å¦å‰‡ç”Ÿæˆæ–°é¡Œç›®
loadNewGame();
}

playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== Modal æ§åˆ¶ =====
function closeInstructions() {
alert(currentLang === 'en' ? 'Please click "Start Game!" button to begin.' : 'è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
}
window.onclick = function(event) {
const modal = document.getElementById('instructionsModal');
if (event.target === modal) {
alert(currentLang === 'en' ? 'Please click "Start Game!" button to begin.' : 'è«‹é»æ“Šã€Œé–‹å§‹éŠæˆ²ï¼ã€æŒ‰éˆ•ä»¥é–‹å§‹éŠæˆ²ã€‚');
}
};

// ===== é‡æ–°é–‹å§‹ =====
function restartGame() {
if (timer) {
clearInterval(timer);
timer = null;
}
document.getElementById('successModal').style.display = 'none';
document.getElementById('failureModal').style.display = 'none';
document.getElementById('handArea').innerHTML = '';
document.getElementById('targetCard').textContent = '?';
showMessage(translations[currentLang].messageStart, 'info');
if (currentGameSnapshot) {
currentTarget = currentGameSnapshot.target;
originalHand = [...currentGameSnapshot.hand];
score = currentGameSnapshot.score;
timeLeft = currentGameSnapshot.timeLeft;
document.getElementById('score').textContent = score;
document.getElementById('timeLeft').textContent = timeLeft;
} else {
score = 0;
combo = 0;
currentStep = 0;
timeLeft = 60;
document.getElementById('score').textContent = '0';
document.getElementById('timeLeft').textContent = '60';
}
playReadyGoSound(() => {
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== ç¹¼çºŒæŒ‘æˆ° =====
function continueChallenge() {
if (timer) {
clearInterval(timer);
timer = null;
}
document.getElementById('successModal').style.display = 'none';
document.getElementById('failureModal').style.display = 'none';
currentTarget = null;
originalHand = [];
score = 0;
combo = 0;
currentStep = 0;
isGameActive = false;
timeLeft = 60;
document.getElementById('score').textContent = '0';
document.getElementById('timeLeft').textContent = '60';
document.getElementById('message').textContent = translations[currentLang].messageStart;
document.getElementById('message').className = 'message info';
document.getElementById('handArea').innerHTML = '';
document.getElementById('targetCard').textContent = '?';
playReadyGoSound(() => {
loadNewGame();
document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
const handArea = document.getElementById('handArea');
handArea.innerHTML = '';
for (let i = 0; i < originalHand.length; i++) {
handArea.appendChild(createCard(originalHand[i]));
}
startTimer();
});
}

// ===== å•Ÿå‹•éŠæˆ² =====
document.addEventListener('DOMContentLoaded', () => {
  // è§£æèªè¨€
  currentLang = parseUrlLanguage();
  
  // åˆå§‹åŒ–ç‹€æ…‹
  currentTarget = null;
  originalHand = [];
  score = 0;
  combo = 0;
  currentStep = 0;
  isGameActive = false;
  timeLeft = 60;
  timer = null;
  currentGameSnapshot = null;
  volumeEnabled = true;
  currentPuzzle = null;

  document.getElementById('score').textContent = '0';
  document.getElementById('timeLeft').textContent = '60';
  document.getElementById('targetCard').textContent = '?';
  document.getElementById('handArea').innerHTML = '';
  document.getElementById('successModal').style.display = 'none';
  document.getElementById('failureModal').style.display = 'none';

  // è§£æ URL é¡Œç›®
  const urlPuzzle = parseUrlPuzzle();
  if (urlPuzzle) {
    currentGameSnapshot = {
      target: urlPuzzle.target,
      hand: [...urlPuzzle.hand],
      score: 0,
      timeLeft: 60
    };
  }

  // æ›´æ–°èªè¨€
  updateLanguage();

  // é¡¯ç¤ºç©æ³•èªªæ˜
  document.getElementById('instructionsModal').style.display = 'flex';
});
</script>
</body>
</html>
